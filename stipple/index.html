<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>STIPPLE / STUDIO</title>

  <!-- Favicon (Geometric Square) -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%23ff4d4d'/%3E%3Ccircle cx='50' cy='50' r='20' fill='%23050505'/%3E%3C/svg%3E">

  <!-- Google Fonts: Inter (The neo-grotesque standard) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&display=swap" rel="stylesheet">

  <!-- Google Material Symbols (Sharp) -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Sharp:opsz,wght,FILL,GRAD@24,400,0,0" />

  <!-- TailwindCSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Tailwind Configuration -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'sans-serif'],
            mono: ['"JetBrains Mono"', 'monospace'], // Technical feel
          },
          colors: {
            'swiss-bg': '#050505',
            'swiss-fg': '#ffffff',
            'swiss-accent': '#ff4d4d', // Swiss Red
            'swiss-border': '#333333',
            'swiss-surface': '#111111',
          },
          spacing: {
            '18': '4.5rem',
          }
        }
      }
    }
  </script>

  <style>
    /* Neo-Swiss Global Reset & Styles */
    body {
      background-color: #050505;
      color: #ffffff;
      font-family: 'Inter', sans-serif;
      overflow: hidden; /* App-like feel */
    }

    /* Force sharp corners everywhere */
    * {
      border-radius: 0 !important;
    }

    /* Grid Lines Pattern */
    .bg-grid-pattern {
      background-size: 40px 40px;
      background-image:
        linear-gradient(to right, #1a1a1a 1px, transparent 1px),
        linear-gradient(to bottom, #1a1a1a 1px, transparent 1px);
    }

    /* Custom Scrollbar - Minimalist */
    ::-webkit-scrollbar {
      width: 4px;
      height: 4px;
    }
    ::-webkit-scrollbar-track {
      background: #050505;
    }
    ::-webkit-scrollbar-thumb {
      background: #ff4d4d;
    }

    /* Range Slider - Technical Style */
    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 2px;
      background: #333;
      outline: none;
      margin: 10px 0;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      background: #ff4d4d;
      cursor: pointer;
      border: 1px solid #ff4d4d;
      transition: all 0.1s ease;
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.5);
      background: #fff;
    }

    /* Custom Checkbox - Square */
    .custom-checkbox input:checked ~ .checkmark {
      background-color: #ff4d4d;
      border-color: #ff4d4d;
    }
    .custom-checkbox .checkmark:after {
      content: "";
      position: absolute;
      display: none;
      left: 6px;
      top: 2px;
      width: 4px;
      height: 10px;
      border: solid black;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }
    .custom-checkbox input:checked ~ .checkmark:after {
      display: block;
    }

    /* Color Input */
    input[type="color"] {
      -webkit-appearance: none;
      width: 100%;
      height: 30px;
      border: 1px solid #333;
      padding: 0;
      background: none;
    }
    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 2px;
    }
    input[type="color"]::-webkit-color-swatch {
      border: none;
    }

    /* Utility to hide file input */
    .hidden { display: none; }

    /* Vertical Text */
    .vertical-text {
      writing-mode: vertical-rl;
      text-orientation: mixed;
    }

    /* Custom Select Styling */
    .custom-select-container {
      position: relative;
    }
    .custom-select {
      appearance: none;
      background-color: #050505;
      border: 1px solid #333;
      padding: 0.5rem 2rem 0.5rem 0.75rem;
      width: 100%;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.875rem;
      color: #fff;
      cursor: pointer;
      border-radius: 0;
    }
    .custom-select:focus {
      outline: none;
      border-color: #ff4d4d;
    }
    .custom-select-icon {
      pointer-events: none;
      position: absolute;
      top: 0;
      bottom: 0;
      right: 0;
      display: flex;
      align-items: center;
      padding-right: 0.5rem;
      color: #ff4d4d;
    }
  </style>
</head>
<body class="h-screen w-screen flex flex-col bg-swiss-bg text-swiss-fg overflow-hidden selection:bg-swiss-accent selection:text-black">

  <!-- Header / Top Bar -->
  <header class="h-14 border-b border-swiss-border flex items-center justify-between px-6 bg-swiss-bg z-10">
    <div class="flex items-center gap-3">
      <div class="w-4 h-4 bg-swiss-accent"></div>
      <h1 class="text-lg font-bold tracking-tighter uppercase">Stipple<span class="font-light opacity-50">Studio</span></h1>
    </div>
    <div class="text-xs font-mono text-gray-500 uppercase tracking-widest">
      v2.1 // Neo-Swiss Layout // Multi-Effect
    </div>
  </header>

  <!-- Main Layout -->
  <main class="flex-1 flex overflow-hidden">

    <!-- LEFT PANEL: CONTROLS -->
    <aside class="w-80 border-r border-swiss-border bg-swiss-bg flex flex-col z-10 shadow-2xl shadow-black">
      <div class="p-4 border-b border-swiss-border">
        <h2 class="text-xs font-bold uppercase tracking-widest text-gray-500 mb-1">Source</h2>
        <!-- File Upload Area -->
        <div id="upload-container" class="border border-dashed border-gray-600 hover:border-swiss-accent hover:bg-swiss-surface transition-colors h-32 flex flex-col items-center justify-center cursor-pointer group">
          <span class="material-symbols-sharp text-3xl text-gray-500 group-hover:text-swiss-accent mb-2">upload_file</span>
          <p class="text-xs font-mono uppercase text-gray-400 group-hover:text-white">Select Image</p>
          <input type="file" id="imageLoader" accept="image/*" class="hidden">
        </div>
      </div>

      <div class="flex-1 overflow-y-auto p-6 space-y-8">
        
        <!-- Style Selection -->
        <div class="control-group">
          <label class="block text-xs font-bold uppercase tracking-widest mb-2">Effect Style</label>
          <div class="custom-select-container">
            <select id="effectStyle" class="custom-select">
              <option value="original">Original (Dot Grid)</option>
              <option value="halftone">Halftone Screen</option>
              <option value="scribble">Scribble / Sketch</option>
              <option value="random">Randomized Dots</option>
            </select>
            <div class="custom-select-icon">
              <span class="material-symbols-sharp text-sm">expand_more</span>
            </div>
          </div>
        </div>

        <!-- Density -->
        <div class="control-group">
          <div class="flex justify-between items-end mb-2">
            <label class="text-xs font-bold uppercase tracking-widest">Grid Density</label>
            <span id="density-value" class="text-xs font-mono text-swiss-accent">10px</span>
          </div>
          <input type="range" id="density" min="2" max="30" value="10">
        </div>

        <!-- Dot Size -->
        <div class="control-group">
          <div class="flex justify-between items-end mb-2">
            <label class="text-xs font-bold uppercase tracking-widest" id="dotSizeLabel">Dot Diameter</label>
            <span id="dotSize-value" class="text-xs font-mono text-swiss-accent">5px</span>
          </div>
          <input type="range" id="dotSize" min="1" max="50" value="5">
        </div>

        <!-- Intensity -->
        <div class="control-group">
          <div class="flex justify-between items-end mb-2">
            <label class="text-xs font-bold uppercase tracking-widest">Tone Mapping</label>
            <span id="amount-value" class="text-xs font-mono text-swiss-accent">1.0</span>
          </div>
          <input type="range" id="amount" min="0" max="3" step="0.1" value="1">
        </div>

        <!-- Toggles -->
        <div class="space-y-3 pt-4 border-t border-swiss-border">
          <div class="flex items-center justify-between">
            <label class="text-xs font-bold uppercase tracking-widest text-gray-400">Preserve Color</label>
            <label class="custom-checkbox relative inline-block w-5 h-5 border border-gray-600 cursor-pointer">
              <input type="checkbox" id="originalColors" class="opacity-0 w-0 h-0">
              <span class="checkmark absolute top-0 left-0 w-full h-full bg-transparent"></span>
            </label>
          </div>

          <div class="flex items-center justify-between">
            <label class="text-xs font-bold uppercase tracking-widest text-gray-400">Invert Value</label>
            <label class="custom-checkbox relative inline-block w-5 h-5 border border-gray-600 cursor-pointer">
              <input type="checkbox" id="invertEffect" class="opacity-0 w-0 h-0">
              <span class="checkmark absolute top-0 left-0 w-full h-full bg-transparent"></span>
            </label>
          </div>
        </div>

        <!-- Color Picker -->
        <div id="stippleColorContainer" class="pt-2">
           <label class="block text-xs font-bold uppercase tracking-widest mb-2">Ink Color</label>
           <div class="flex gap-2">
             <input type="color" id="colorPicker" value="#ffffff" class="flex-1 cursor-pointer hover:opacity-80 transition-opacity">
           </div>
        </div>

      </div>
    </aside>

    <!-- CENTER PANEL: CANVAS -->
    <section class="flex-1 bg-neutral-900 bg-grid-pattern relative flex flex-col min-w-0">
      
      <!-- Canvas Toolbar -->
      <div class="absolute top-4 right-4 z-20 flex gap-2">
         <div class="bg-swiss-bg border border-swiss-border px-3 py-2 flex items-center gap-3 shadow-lg">
            <span class="text-xs font-mono uppercase text-gray-500">Background</span>
            <input type="color" id="canvasColor" value="#050505" class="w-6 h-6 border border-gray-600">
         </div>
      </div>

      <!-- Canvas Container -->
      <div id="canvas-container" class="flex-1 flex items-center justify-center p-8 overflow-hidden">
        <canvas id="stippleCanvas" class="shadow-[0_0_0_1px_rgba(255,255,255,0.1)] max-w-full max-h-full object-contain"></canvas>
      </div>

      <!-- Footer Info -->
      <div class="absolute bottom-0 left-0 w-full border-t border-swiss-border bg-swiss-bg px-4 py-2 flex justify-between text-[10px] font-mono uppercase text-gray-500">
        <span>X: <span id="info-w">0</span>px</span>
        <span>Y: <span id="info-h">0</span>px</span>
      </div>
    </section>

    <!-- RIGHT PANEL: EXPORT -->
    <aside class="w-72 border-l border-swiss-border bg-swiss-bg flex flex-col z-10">
      <div class="p-4 border-b border-swiss-border bg-swiss-surface">
        <h2 class="text-xs font-bold uppercase tracking-widest">Output Settings</h2>
      </div>

      <div class="flex-1 p-6 space-y-8 overflow-y-auto">
        
        <!-- Format Selection -->
        <div class="control-group">
          <label class="block text-xs font-bold uppercase tracking-widest mb-2">Format</label>
          <div class="custom-select-container">
            <select id="exportFormat" class="custom-select">
              <option value="png">PNG (Raster)</option>
              <option value="jpeg">JPEG (Raster)</option>
              <option value="svg">SVG (Vector)</option>
            </select>
            <div class="custom-select-icon">
              <span class="material-symbols-sharp text-sm">expand_more</span>
            </div>
          </div>
        </div>

        <!-- Scale -->
        <div id="scaleContainer" class="control-group">
          <div class="flex justify-between items-end mb-2">
            <label class="text-xs font-bold uppercase tracking-widest">Scale Multiplier</label>
            <span id="scale-value" class="text-xs font-mono text-swiss-accent">1.0x</span>
          </div>
          <input type="range" id="scaleSlider" min="1" max="5" step="0.5" value="1">
        </div>

        <!-- PNG Options -->
        <div id="transparentBgContainer" class="flex items-center justify-between pt-2">
            <label class="text-xs font-bold uppercase tracking-widest text-gray-400">Transparent BG</label>
            <label class="custom-checkbox relative inline-block w-5 h-5 border border-gray-600 cursor-pointer">
              <input type="checkbox" id="transparentBg" class="opacity-0 w-0 h-0">
              <span class="checkmark absolute top-0 left-0 w-full h-full bg-transparent"></span>
            </label>
        </div>

        <!-- BG Color for Export -->
        <div id="bgColorContainer" class="control-group">
          <label class="block text-xs font-bold uppercase tracking-widest mb-2">Matte Color</label>
          <input type="color" id="bgColor" value="#050505" class="w-full h-8 border border-gray-600 cursor-pointer">
        </div>

         <!-- Quality for JPEG -->
         <div id="qualityContainer" class="control-group hidden">
            <div class="flex justify-between items-end mb-2">
              <label class="text-xs font-bold uppercase tracking-widest">Compression</label>
              <span id="quality-value" class="text-xs font-mono text-swiss-accent">90%</span>
            </div>
            <input type="range" id="qualitySlider" min="0.1" max="1" step="0.05" value="0.9">
          </div>

      </div>

      <div class="p-6 border-t border-swiss-border">
        <button id="downloadBtn" class="w-full bg-swiss-accent text-black font-bold uppercase tracking-wider py-4 hover:bg-white transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2 group">
          <span>Export</span>
          <span class="material-symbols-sharp text-sm group-hover:translate-x-1 transition-transform">arrow_forward</span>
        </button>
      </div>
    </aside>

  </main>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // --- DOM Elements ---
      const imageLoader = document.getElementById('imageLoader');
      const uploadContainer = document.getElementById('upload-container');
      const canvas = document.getElementById('stippleCanvas');
      const ctx = canvas.getContext('2d');
      
      const effectStyleSelect = document.getElementById('effectStyle');
      const densitySlider = document.getElementById('density');
      const dotSizeSlider = document.getElementById('dotSize');
      const amountSlider = document.getElementById('amount');
      const originalColorsCheckbox = document.getElementById('originalColors');
      const colorPicker = document.getElementById('colorPicker');
      const stippleColorContainer = document.getElementById('stippleColorContainer');
      const invertEffectCheckbox = document.getElementById('invertEffect');

      const densityValue = document.getElementById('density-value');
      const dotSizeValue = document.getElementById('dotSize-value');
      const dotSizeLabel = document.getElementById('dotSizeLabel');
      const amountValue = document.getElementById('amount-value');

      const exportFormatSelect = document.getElementById('exportFormat');
      const transparentCheckbox = document.getElementById('transparentBg');
      const bgColorPicker = document.getElementById('bgColor');
      const transparentBgContainer = document.getElementById('transparentBgContainer');
      const bgColorContainer = document.getElementById('bgColorContainer');
      const qualityContainer = document.getElementById('qualityContainer');
      const qualitySlider = document.getElementById('qualitySlider');
      const qualityValue = document.getElementById('quality-value');
      const scaleContainer = document.getElementById('scaleContainer');
      const scaleSlider = document.getElementById('scaleSlider');
      const scaleValue = document.getElementById('scale-value');
      const downloadBtn = document.getElementById('downloadBtn');

      const canvasColorPicker = document.getElementById('canvasColor');
      const canvasContainer = document.getElementById('canvas-container');
      const infoW = document.getElementById('info-w');
      const infoH = document.getElementById('info-h');

      // --- State ---
      let img = new Image();
      const offCanvas = document.createElement('canvas');
      const offCtx = offCanvas.getContext('2d');

      // --- Initial Setup ---
      const setupInitialCanvas = () => {
        const dpr = window.devicePixelRatio || 1;
        // A nice default technical drawing size
        canvas.width = 600 * dpr;
        canvas.height = 400 * dpr;
        ctx.scale(dpr, dpr);
        
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        
        // Draw an X for placeholder
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(canvas.width, canvas.height);
        ctx.moveTo(canvas.width, 0);
        ctx.lineTo(0, canvas.height);
        ctx.stroke();

        ctx.font = "12px 'JetBrains Mono'";
        ctx.fillStyle = "#666";
        ctx.textAlign = "center";
        ctx.fillText("NO SIGNAL / LOAD IMAGE", canvas.width / (2*dpr), canvas.height / (2*dpr));
        
        downloadBtn.disabled = true;
      };
      setupInitialCanvas();

      // --- Event Listeners ---

      // File Upload
      uploadContainer.addEventListener('click', () => imageLoader.click());
      uploadContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadContainer.classList.add('border-swiss-accent', 'bg-swiss-surface');
      });
      uploadContainer.addEventListener('dragleave', () => {
        uploadContainer.classList.remove('border-swiss-accent', 'bg-swiss-surface');
      });
      uploadContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadContainer.classList.remove('border-swiss-accent', 'bg-swiss-surface');
        if (e.dataTransfer.files.length) {
          imageLoader.files = e.dataTransfer.files;
          imageLoader.dispatchEvent(new Event('change'));
        }
      });
      imageLoader.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          img = new Image();
          img.onload = () => {
            downloadBtn.disabled = false;
            infoW.textContent = img.width;
            infoH.textContent = img.height;
            applyStipple();
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });

      // Control Listeners
      const controls = [densitySlider, dotSizeSlider, amountSlider, colorPicker, bgColorPicker, canvasColorPicker];
      controls.forEach(control => control.addEventListener('input', applyStipple));
      
      const checkboxes = [originalColorsCheckbox, invertEffectCheckbox, transparentCheckbox];
      checkboxes.forEach(checkbox => checkbox.addEventListener('change', applyStipple));

      effectStyleSelect.addEventListener('change', () => {
        const style = effectStyleSelect.value;
        if (style === 'scribble') {
          dotSizeLabel.textContent = 'Stroke Width';
        } else {
          dotSizeLabel.textContent = 'Dot Diameter';
        }
        applyStipple();
      });

      // Update UI based on control changes
      densitySlider.addEventListener('input', () => densityValue.textContent = densitySlider.value + 'px');
      dotSizeSlider.addEventListener('input', () => dotSizeValue.textContent = dotSizeSlider.value + 'px');
      amountSlider.addEventListener('input', () => amountValue.textContent = parseFloat(amountSlider.value).toFixed(1));
      qualitySlider.addEventListener('input', () => qualityValue.textContent = Math.round(qualitySlider.value * 100) + '%');
      scaleSlider.addEventListener('input', () => scaleValue.textContent = `${parseFloat(scaleSlider.value).toFixed(1)}x`);

      originalColorsCheckbox.addEventListener('change', () => {
        stippleColorContainer.style.display = originalColorsCheckbox.checked ? 'none' : 'block';
        applyStipple();
      });

      exportFormatSelect.addEventListener('change', () => {
        const format = exportFormatSelect.value;
        transparentBgContainer.style.display = format === 'png' ? 'flex' : 'none';
        bgColorContainer.style.display = (format === 'png' && transparentCheckbox.checked) ? 'none' : 'block';
        qualityContainer.style.display = format === 'jpeg' ? 'block' : 'none';
        scaleContainer.style.display = format === 'svg' ? 'none' : 'block';
      });

      transparentCheckbox.addEventListener('change', () => {
        bgColorContainer.style.display = transparentCheckbox.checked ? 'none' : 'block';
      });

      canvasColorPicker.addEventListener('input', () => {
        canvasContainer.style.backgroundColor = canvasColorPicker.value;
      });

      // Download Handler
      downloadBtn.addEventListener('click', handleDownload);

      // --- Core Functions ---

      function applyStipple() {
        if (!img.src) return;
        drawStipple(canvas, true, 1);
      }

      function drawStipple(targetCanvas, isPreview, scale = 1) {
        const ctx = targetCanvas.getContext('2d');
        const w = img.width * scale;
        const h = img.height * scale;
        targetCanvas.width = w;
        targetCanvas.height = h;

        // Set background
        const useTransparent = exportFormatSelect.value === 'png' && transparentCheckbox.checked;
        if (!isPreview && !useTransparent) {
          ctx.fillStyle = bgColorPicker.value;
          ctx.fillRect(0, 0, w, h);
        } else if (isPreview) {
            ctx.clearRect(0, 0, w, h);
        } else {
            ctx.clearRect(0, 0, w, h);
        }

        // Get pixel data
        offCanvas.width = img.width;
        offCanvas.height = img.height;
        offCtx.drawImage(img, 0, 0);
        const imageData = offCtx.getImageData(0, 0, img.width, img.height).data;

        // Get settings
        const style = effectStyleSelect.value;
        const density = parseInt(densitySlider.value, 10);
        const dotSizeBase = parseFloat(dotSizeSlider.value);
        const amount = parseFloat(amountSlider.value);
        const useOriginalColors = originalColorsCheckbox.checked;
        const customColor = colorPicker.value;
        const invert = invertEffectCheckbox.checked;

        for (let y = 0; y < img.height; y += density) {
          for (let x = 0; x < img.width; x += density) {
            const i = (y * img.width + x) * 4;
            const r = imageData[i], g = imageData[i + 1], b = imageData[i + 2], a = imageData[i+3];
            
            if (a < 5) continue;

            const brightness = (r + g + b) / 3 / 255;
            let val = invert ? brightness : 1 - brightness;
            val = Math.pow(val, amount); // Apply gamma/intensity curve

            const color = useOriginalColors ? `rgb(${r},${g},${b})` : customColor;
            ctx.fillStyle = color;
            ctx.strokeStyle = color;

            let drawX = x * scale;
            let drawY = y * scale;

            if (style === 'original') {
                const radius = dotSizeBase * val;
                if (radius > 0.5) {
                  ctx.beginPath();
                  ctx.arc(drawX, drawY, radius * scale, 0, Math.PI * 2);
                  ctx.fill();
                }
            } else if (style === 'halftone') {
                const maxRadius = dotSizeBase / 2;
                const radius = maxRadius * val;
                 if (radius > 0.5) {
                  ctx.beginPath();
                  ctx.arc(drawX, drawY, radius * scale, 0, Math.PI * 2);
                  ctx.fill();
                }
            } else if (style === 'random') {
                const radius = dotSizeBase * val;
                if (radius > 0.5) {
                  // Add random jitter
                  const jitter = density * 0.4 * scale;
                  drawX += (Math.random() - 0.5) * jitter;
                  drawY += (Math.random() - 0.5) * jitter;
                  
                  ctx.beginPath();
                  ctx.arc(drawX, drawY, radius * scale, 0, Math.PI * 2);
                  ctx.fill();
                }
            } else if (style === 'scribble') {
                if (val > 0.1) {
                  ctx.lineWidth = dotSizeBase * scale * 0.5;
                  const len = density * scale * val;
                  const angle = Math.random() * Math.PI * 2;
                  
                  ctx.beginPath();
                  ctx.moveTo(drawX - (Math.cos(angle) * len), drawY - (Math.sin(angle) * len));
                  // Add a slight curve
                  const cp1x = drawX + (Math.random() - 0.5) * len;
                  const cp1y = drawY + (Math.random() - 0.5) * len;
                  ctx.quadraticCurveTo(cp1x, cp1y, drawX + (Math.cos(angle) * len), drawY + (Math.sin(angle) * len));
                  ctx.stroke();
                }
            }
          }
        }
      }

      function generateSVG() {
        const style = effectStyleSelect.value;
        const density = parseInt(densitySlider.value, 10);
        const dotSizeBase = parseFloat(dotSizeSlider.value);
        const amount = parseFloat(amountSlider.value);
        const useOriginalColors = originalColorsCheckbox.checked;
        const customColor = colorPicker.value;
        const invert = invertEffectCheckbox.checked;

        let svgContent = '';
        offCanvas.width = img.width;
        offCanvas.height = img.height;
        offCtx.drawImage(img, 0, 0);
        const imageData = offCtx.getImageData(0, 0, img.width, img.height).data;

        for (let y = 0; y < img.height; y += density) {
          for (let x = 0; x < img.width; x += density) {
            const i = (y * img.width + x) * 4;
            const r = imageData[i], g = imageData[i + 1], b = imageData[i + 2], a = imageData[i+3];
            
            if (a < 5) continue;

            const brightness = (r + g + b) / 3 / 255;
            let val = invert ? brightness : 1 - brightness;
            val = Math.pow(val, amount);

            const color = useOriginalColors ? `rgb(${r},${g},${b})` : customColor;
            let drawX = x;
            let drawY = y;

            if (style === 'original') {
                const radius = dotSizeBase * val;
                if (radius > 0.5) {
                  svgContent += `<circle cx="${drawX}" cy="${drawY}" r="${radius.toFixed(2)}" fill="${color}" />\n`;
                }
            } else if (style === 'halftone') {
                const maxRadius = dotSizeBase / 2;
                const radius = maxRadius * val;
                if (radius > 0.5) {
                  svgContent += `<circle cx="${drawX}" cy="${drawY}" r="${radius.toFixed(2)}" fill="${color}" />\n`;
                }
            } else if (style === 'random') {
                const radius = dotSizeBase * val;
                if (radius > 0.5) {
                  const jitter = density * 0.4;
                  drawX += (Math.random() - 0.5) * jitter;
                  drawY += (Math.random() - 0.5) * jitter;
                  svgContent += `<circle cx="${drawX.toFixed(2)}" cy="${drawY.toFixed(2)}" r="${radius.toFixed(2)}" fill="${color}" />\n`;
                }
            } else if (style === 'scribble') {
                if (val > 0.1) {
                  const strokeWidth = dotSizeBase * 0.5;
                  const len = density * val;
                  const angle = Math.random() * Math.PI * 2;
                  const x1 = drawX - (Math.cos(angle) * len);
                  const y1 = drawY - (Math.sin(angle) * len);
                  const x2 = drawX + (Math.cos(angle) * len);
                  const y2 = drawY + (Math.sin(angle) * len);
                  const cp1x = drawX + (Math.random() - 0.5) * len;
                  const cp1y = drawY + (Math.random() - 0.5) * len;

                  svgContent += `<path d="M${x1.toFixed(1)},${y1.toFixed(1)} Q${cp1x.toFixed(1)},${cp1y.toFixed(1)} ${x2.toFixed(1)},${y2.toFixed(1)}" stroke="${color}" stroke-width="${strokeWidth.toFixed(1)}" fill="none" stroke-linecap="round" />\n`;
                }
            }
          }
        }

        const bgRect = (exportFormatSelect.value === 'png' && transparentCheckbox.checked) ? '' : `<rect width="100%" height="100%" fill="${bgColorPicker.value}" />\n`;
        return `<svg xmlns="http://www.w3.org/2000/svg" width="${img.width}" height="${img.height}" viewBox="0 0 ${img.width} ${img.height}">\n${bgRect}${svgContent}</svg>`;
      }

      function handleDownload() {
        if (!img.src) return;
        const format = exportFormatSelect.value;
        const style = effectStyleSelect.value;
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `STIPPLE_${style.toUpperCase()}_${timestamp}.${format}`;
        let dataURL;

        if (format === 'svg') {
          const svgString = generateSVG();
          const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
          dataURL = URL.createObjectURL(blob);
        } else {
          const scale = parseFloat(scaleSlider.value);
          const exportCanvas = document.createElement('canvas');
          drawStipple(exportCanvas, false, scale);
          const quality = format === 'jpeg' ? parseFloat(qualitySlider.value) : undefined;
          dataURL = exportCanvas.toDataURL(`image/${format}`, quality);
        }

        const link = document.createElement('a');
        link.href = dataURL;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        if (format === 'svg') {
          URL.revokeObjectURL(dataURL);
        }
      }
    });
  </script>
</body>
</html>