<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>METADATA VIEWER</title>

    <!-- Core Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>

    <!-- Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />

    <style>
        /* Base & Fonts */
        body { 
            font-family: 'Poppins', sans-serif; 
            -webkit-font-smoothing: antialiased; 
            -moz-osx-font-smoothing: grayscale; 
        }
        .material-symbols-outlined { 
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24; 
            vertical-align: middle; 
        }

        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f3f4f6; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 10px; border: 2px solid #f3f4f6; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        /* Drop Zone Animation */
        .drop-zone-base { 
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease; 
        }
        .drop-zone-base.dragover { 
            border-color: #dc2626; 
            background-color: #fee2e2; 
            box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.2); 
        }

        /* Modal Styling */
        #imageModal { 
            transition: opacity 0.3s ease, visibility 0.3s ease; 
        }
        #imageModal:not(.hidden) { opacity: 1; visibility: visible; }
        #imageModal.hidden { opacity: 0; visibility: hidden; }
        body.modal-open { overflow: hidden; }

        /* Toast Notification Animation */
        .custom-toast { animation: toast-in 0.5s ease forwards; }
        .custom-toast.fade-out { animation: toast-out 0.5s ease forwards; }
        @keyframes toast-in { from { opacity: 0; transform: translate(-50%, 20px); } to { opacity: 1; transform: translate(-50%, 0); } }
        @keyframes toast-out { from { opacity: 1; transform: translate(-50%, 0); } to { opacity: 0; transform: translate(-50%, 20px); } }

        /* Metadata Content Styling */
        pre { 
            white-space: pre-wrap; 
            word-wrap: break-word; 
        }
        pre .copy-btn { 
            position: absolute; 
            top: 0.5rem; 
            right: 0.5rem; 
            opacity: 0.6; 
            transition: opacity 0.2s ease, background-color 0.2s ease; 
        }
        pre:hover .copy-btn { opacity: 1; }
        pre .copy-btn:hover { background-color: rgba(0, 0, 0, 0.08); }

        /* Tab Styling & Transition */
        .tab-btn {
            padding: 0.75rem 1.5rem;
            font-weight: 500;
            color: #4b5563; /* gray-600 */
            border-bottom: 2px solid transparent;
            transition: color 0.2s ease, border-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }
        .tab-btn:hover {
            color: #dc2626; /* red-600 */
        }
        .tab-btn.active {
            color: #dc2626; /* red-600 */
            border-bottom-color: #dc2626; /* red-600 */
            font-weight: 600;
        }
        
        .tab-content {
            /* Base styles for tab content structure are applied by Tailwind (flex, flex-col, etc.) */
            /* Transition properties for smooth animation */
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: opacity, transform; /* Hint for browser performance */
        }

        /* State for a tab that is about to be shown or has just been hidden (animating out to this state) */
        .tab-content-prepared {
            opacity: 0;
            transform: translateY(15px);
        }

        /* State for an active, fully visible tab (animating in to this state) */
        .tab-content-active {
            opacity: 1;
            transform: translateY(0px);
        }
        /* Tailwind's .hidden class (display: none !important) is used to remove from layout when not active/transitioning */

    </style>

    <script>
      // Tailwind CSS Configuration
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: { sans: ['Poppins', 'sans-serif'], },
            boxShadow: { 'subtle': '0 4px 12px rgba(0, 0, 0, 0.05)', 'card': '0 8px 20px rgba(0, 0, 0, 0.07)', },
            maxHeight: { 'modal-img': 'calc(100vh - 8rem)', 'preview-area': 'calc(100vh - 20rem)', 'bulk-list': 'calc(100vh - 28rem)' }
          }
        }
      }
    </script>
</head>
<body class="bg-gradient-to-br from-gray-50 to-gray-200 text-gray-800 flex items-center justify-center min-h-screen p-4 sm:p-8 overflow-hidden">

  <div class="container max-w-7xl w-full bg-white rounded-2xl shadow-card p-6 md:p-10 flex flex-col max-h-[95vh] h-full">
    <!-- Header Section -->
    <div class="title-section text-center border-b border-gray-200 pb-4 mb-2 flex-shrink-0">
      <h3 class="text-3xl sm:text-4xl font-bold text-gray-800 tracking-tight flex items-center justify-center gap-3">
        <span class="material-symbols-outlined text-red-600 text-4xl">policy</span>METADATA VIEWER
      </h3>
      <p class="text-gray-500 text-sm mt-1">Inspect image metadata or strip it in bulk. All processing is done in your browser.</p>
    </div>

    <!-- Tab Navigation -->
    <div class="tabs-container mb-6 flex border-b border-gray-200 flex-shrink-0">
        <button id="singleImageTabBtn" class="tab-btn"> <!-- Initial active state set by JS -->
            <span class="material-symbols-outlined text-xl">image_search</span>Single Image Inspector
        </button>
        <button id="bulkStripTabBtn" class="tab-btn">
            <span class="material-symbols-outlined text-xl">auto_fix_high</span>Bulk Metadata Stripper
        </button>
    </div>

    <!-- Tab Content Area -->
    <!-- The parent div for tab content panels. It handles overall flex growth and overflow. -->
    <div class="flex-grow overflow-hidden flex flex-col">

        <!-- Single Image Inspector Tab Content -->
        <!-- `tab-content` class is essential. `hidden`, `tab-content-prepared`, `tab-content-active` are managed by JS -->
        <div id="singleImageTabContent" class="tab-content flex flex-col flex-grow overflow-hidden"> <!-- Added flex flex-col flex-grow overflow-hidden here -->
            <div class="content-area flex flex-col lg:flex-row gap-8 flex-grow overflow-hidden">
                <!-- Left Column: Upload, Preview, and Actions -->
                <div class="left-column lg:w-2/5 flex flex-col gap-6 overflow-hidden">
                    <div id="dropZone" class="drop-zone-base border-2 border-dashed border-gray-300 rounded-xl p-6 sm:py-8 flex flex-col items-center justify-center text-center text-gray-600 cursor-pointer hover:border-red-500 hover:bg-red-50 hover:text-red-700 flex-shrink-0 group">
                        <span class="material-symbols-outlined text-5xl mb-3 text-gray-400 group-hover:text-red-500">upload_file</span>
                        <span class="font-semibold text-lg text-gray-700 group-hover:text-red-700">Drop Image Here</span>
                        <span class="text-gray-500 text-sm mt-1">or click to select (PNG, JPG, WEBP)</span>
                        <span class="text-gray-400 text-xs mt-3">(Paste with Ctrl+V)</span>
                    </div>
                    <div class="image-preview-container border border-gray-200 rounded-xl overflow-hidden flex justify-center items-center bg-gray-100 relative group flex-grow min-h-0">
                        <img id="imagePreview" alt="Image Preview" class="object-contain max-w-full max-h-full hidden group-hover:opacity-90 transition-opacity duration-300 cursor-pointer" />
                        <div id="previewPlaceholder" class="text-gray-400 flex flex-col items-center text-center p-4">
                            <span class="material-symbols-outlined text-6xl">image</span>
                            <span class="mt-2 text-sm">Image preview will appear here</span>
                        </div>
                    </div>
                    <!-- Action Buttons -->
                    <div id="actionsContainer" class="flex-shrink-0 flex flex-col sm:flex-row gap-3 justify-center">
                        <button id="stripButton" class="hidden w-full sm:w-auto justify-center bg-red-600 hover:bg-red-700 text-white font-semibold py-2.5 px-5 rounded-lg flex items-center gap-2 transition-all duration-200 shadow-md hover:shadow-lg disabled:opacity-50 disabled:cursor-wait disabled:shadow-none">
                            <span class="material-symbols-outlined">shield</span>Strip Metadata
                        </button>
                        <a id="downloadButton" class="hidden w-full sm:w-auto justify-center bg-green-600 hover:bg-green-700 text-white font-semibold py-2.5 px-5 rounded-lg flex items-center gap-2 transition-all duration-200 shadow-md hover:shadow-lg" href="#" download="cleaned_image.png">
                            <span class="material-symbols-outlined">download</span>Download Cleaned
                        </a>
                        <button id="resetButton" class="hidden w-full sm:w-auto justify-center bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2.5 px-5 rounded-lg flex items-center gap-2 transition-all duration-200 shadow-md hover:shadow-lg">
                            <span class="material-symbols-outlined">refresh</span>Reset
                        </button>
                    </div>
                    <input type="file" id="fileInput" accept="image/png, image/jpeg, image/webp, image/gif, image/bmp" class="hidden" />
                </div>

                <!-- Right Column: Metadata Display -->
                <div class="right-column lg:w-3/5 flex flex-col overflow-hidden">
                    <div class="flex justify-between items-center mb-4 flex-shrink-0">
                        <h4 class="text-xl font-semibold text-gray-700 flex items-center gap-2">
                            <span class="material-symbols-outlined text-red-600">description</span>
                            Extracted Metadata
                        </h4>
                        <button id="copyAllMetadataBtn" class="hidden bg-red-500 hover:bg-red-600 text-white text-xs font-medium py-1.5 px-3 rounded-md flex items-center gap-1.5 transition-colors duration-150">
                            <span class="material-symbols-outlined text-sm leading-none">inventory_2</span>
                            Copy All Raw
                        </button>
                    </div>
                    <div id="metadataOutput" class="custom-scrollbar flex-grow bg-gray-100 border border-gray-200 rounded-xl p-5 overflow-y-auto min-h-0">
                        <div class="no-metadata flex flex-col items-center justify-center h-full text-gray-500 text-center">
                            <span class="material-symbols-outlined text-6xl mb-3">search_off</span>
                            <p class="font-medium">No metadata to display yet.</p>
                            <p class="text-sm">Upload an image to inspect its data.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bulk Metadata Stripper Tab Content -->
        <div id="bulkStripTabContent" class="tab-content flex flex-col flex-grow overflow-hidden"> <!-- Added flex flex-col flex-grow overflow-hidden here -->
            <div class="flex flex-col gap-6 flex-grow overflow-hidden"> <!-- This inner div now handles the specific layout of bulk tab -->
                <div id="bulkDropZone" class="drop-zone-base border-2 border-dashed border-gray-300 rounded-xl p-6 sm:py-8 flex flex-col items-center justify-center text-center text-gray-600 cursor-pointer hover:border-red-500 hover:bg-red-50 hover:text-red-700 flex-shrink-0 group">
                    <span class="material-symbols-outlined text-5xl mb-3 text-gray-400 group-hover:text-red-500">upload_file</span>
                    <span class="font-semibold text-lg text-gray-700 group-hover:text-red-700">Drop Multiple Images Here</span>
                    <span class="text-gray-500 text-sm mt-1">or click to select (PNG, JPG, WEBP)</span>
                </div>
                <input type="file" id="bulkFileInput" accept="image/png, image/jpeg, image/webp" class="hidden" multiple />

                <div class="bulk-actions-container flex flex-col sm:flex-row gap-3 justify-center flex-shrink-0">
                    <button id="stripAllBulkButton" class="w-full sm:w-auto justify-center bg-red-600 hover:bg-red-700 text-white font-semibold py-2.5 px-5 rounded-lg flex items-center gap-2 transition-all duration-200 shadow-md hover:shadow-lg disabled:opacity-50 disabled:cursor-wait disabled:shadow-none">
                        <span class="material-symbols-outlined">auto_fix_high</span>Strip All Metadata
                    </button>
                    <button id="downloadAllCleanedBulkButton" class="w-full sm:w-auto justify-center bg-green-600 hover:bg-green-700 text-white font-semibold py-2.5 px-5 rounded-lg flex items-center gap-2 transition-all duration-200 shadow-md hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed">
                        <span class="material-symbols-outlined">download_for_offline</span>Download All Cleaned
                    </button>
                    <button id="clearBulkQueueButton" class="w-full sm:w-auto justify-center bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2.5 px-5 rounded-lg flex items-center gap-2 transition-all duration-200 shadow-md hover:shadow-lg">
                        <span class="material-symbols-outlined">delete_sweep</span>Clear Queue
                    </button>
                </div>
                
                <div class="bulk-image-list-container flex-grow overflow-hidden border border-gray-200 rounded-xl bg-gray-50">
                    <div id="bulkImageListHeader" class="p-3 border-b border-gray-200 bg-gray-100 text-xs text-gray-600 font-semibold hidden">
                        <div class="grid grid-cols-[auto_1fr_100px_120px_100px] gap-2 items-center">
                            <span>Preview</span>
                            <span>Filename</span>
                            <span class="text-center">Size</span>
                            <span class="text-center">Status</span>
                            <span class="text-center">Action</span>
                        </div>
                    </div>
                    <div id="bulkImageList" class="custom-scrollbar overflow-y-auto p-2 space-y-2 max-h-bulk-list">
                        <div id="bulkPlaceholder" class="flex flex-col items-center justify-center h-full text-gray-400 text-center p-4">
                            <span class="material-symbols-outlined text-6xl">imagesmode</span>
                            <span class="mt-2 text-sm">Uploaded images will appear here</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

  </div>

  <!-- Image Modal -->
  <div id="imageModal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-8" aria-labelledby="modal-title" role="dialog" aria-modal="true">
      <div class="relative bg-white p-4 rounded-lg shadow-xl max-w-4xl w-full max-h-full flex flex-col">
          <div class="flex justify-between items-center pb-3 border-b border-gray-200 flex-shrink-0">
              <h5 id="modal-title" class="text-lg font-medium text-gray-800">Image Preview</h5>
              <button id="closeModalBtn" type="button" class="text-gray-400 bg-transparent hover:bg-gray-200 hover:text-gray-900 rounded-lg text-sm p-1.5 ml-auto inline-flex items-center" aria-label="Close modal">
                  <span class="material-symbols-outlined">close</span>
              </button>
          </div>
          <div class="mt-4 flex-grow overflow-auto flex items-center justify-center">
              <img id="modalImage" src="" alt="Full image preview" class="max-w-full max-h-modal-img object-contain">
          </div>
      </div>
  </div>

  <script>
    // --- DOM Elements ---
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const imagePreview = document.getElementById('imagePreview');
    const previewPlaceholder = document.getElementById('previewPlaceholder');
    const metadataOutput = document.getElementById('metadataOutput');
    const copyAllMetadataBtn = document.getElementById('copyAllMetadataBtn');
    const imageModal = document.getElementById('imageModal');
    const modalImage = document.getElementById('modalImage');
    const closeModalBtn = document.getElementById('closeModalBtn');
    const stripButton = document.getElementById('stripButton');
    const downloadButton = document.getElementById('downloadButton');
    const resetButton = document.getElementById('resetButton');

    // Tab Elements
    const singleImageTabBtn = document.getElementById('singleImageTabBtn');
    const bulkStripTabBtn = document.getElementById('bulkStripTabBtn');
    const singleImageTabContent = document.getElementById('singleImageTabContent');
    const bulkStripTabContent = document.getElementById('bulkStripTabContent');

    // Bulk Tab Elements
    const bulkDropZone = document.getElementById('bulkDropZone');
    const bulkFileInput = document.getElementById('bulkFileInput');
    const stripAllBulkButton = document.getElementById('stripAllBulkButton');
    const downloadAllCleanedBulkButton = document.getElementById('downloadAllCleanedBulkButton');
    const clearBulkQueueButton = document.getElementById('clearBulkQueueButton');
    const bulkImageList = document.getElementById('bulkImageList');
    const bulkPlaceholder = document.getElementById('bulkPlaceholder');
    const bulkImageListHeader = document.getElementById('bulkImageListHeader');


    // --- State Variables ---
    let currentFile = null;
    let originalImageDataUrl = null;
    let textToCopy = "";
    let bulkFilesData = []; 
    let nextBulkFileId = 0;

    // --- UI Reset ---
    function resetUI() {
        fileInput.value = '';
        currentFile = null;
        originalImageDataUrl = null;
        textToCopy = "";

        imagePreview.src = '#';
        imagePreview.classList.add('hidden');
        previewPlaceholder.classList.remove('hidden');

        metadataOutput.innerHTML = `<div class="no-metadata flex flex-col items-center justify-center h-full text-gray-500 text-center"><span class="material-symbols-outlined text-6xl mb-3">search_off</span><p class="font-medium">No metadata to display yet.</p><p class="text-sm">Upload an image to inspect its data.</p></div>`;
        
        copyAllMetadataBtn.classList.add('hidden');
        stripButton.classList.add('hidden');
        downloadButton.classList.add('hidden');
        resetButton.classList.add('hidden');
        
        stripButton.disabled = false;
        stripButton.innerHTML = `<span class="material-symbols-outlined">shield</span>Strip Metadata`;
    }

    // --- Modal Logic ---
    function openModal(imageUrl) { if (!imageUrl || imageUrl.endsWith('#')) return; modalImage.src = imageUrl; imageModal.classList.remove('hidden'); document.body.classList.add('modal-open'); document.addEventListener('keydown', handleEscapeKey); }
    function closeModal() { imageModal.classList.add('hidden'); modalImage.src = ""; document.body.classList.remove('modal-open'); document.removeEventListener('keydown', handleEscapeKey); }
    function handleEscapeKey(event) { if (event.key === 'Escape') closeModal(); }
    imagePreview.addEventListener('click', () => openModal(imagePreview.src));
    closeModalBtn.addEventListener('click', closeModal);
    imageModal.addEventListener('click', (event) => { if (event.target === imageModal) closeModal(); });

    // --- Toast Notification ---
    function showToast(message, icon = 'info', type = 'info', duration = 3000) {
        document.querySelectorAll('.custom-toast').forEach(t => t.remove()); const toast = document.createElement('div');
        toast.className = 'custom-toast fixed bottom-6 left-1/2 -translate-x-1/2 text-sm font-medium px-5 py-3 rounded-lg shadow-lg flex items-center gap-2 z-[100]';
        let bgColor = 'bg-gray-800', textColor = 'text-white', iconColor = 'text-white';
        if (type === 'success') { bgColor = 'bg-green-600'; icon = 'check_circle'; }
        else if (type === 'error') { bgColor = 'bg-red-600'; icon = 'error'; }
        else if (type === 'warning') { bgColor = 'bg-yellow-500'; textColor = 'text-yellow-900'; iconColor = 'text-yellow-900'; icon = 'warning'; }
        toast.classList.add(bgColor, textColor); const iconSpan = document.createElement('span'); iconSpan.className = `material-symbols-outlined ${iconColor}`; iconSpan.textContent = icon; toast.appendChild(iconSpan);
        const messageSpan = document.createElement('span'); messageSpan.textContent = message; toast.appendChild(messageSpan);
        document.body.appendChild(toast); setTimeout(() => { toast.classList.add('fade-out'); toast.addEventListener('animationend', () => toast.remove()); }, duration);
    }

    // --- Clipboard Functionality ---
    function copyToClipboard(text, elementToFeedback) {
        navigator.clipboard.writeText(text).then(() => {
            showToast('Copied!', 'content_copy', 'success', 1500);
            if (!elementToFeedback) return;
            const icon = elementToFeedback.querySelector('.material-symbols-outlined');
            const originalIcon = icon ? icon.textContent : null;
            const originalTextContent = elementToFeedback.textContent; 
            const originalClasses = Array.from(elementToFeedback.classList);
            
            elementToFeedback.classList.remove('bg-red-500', 'hover:bg-red-600', 'bg-gray-200');
            elementToFeedback.classList.add('bg-green-500', 'hover:bg-green-600');
            if(icon) icon.textContent = 'check';
            
            const textNode = Array.from(elementToFeedback.childNodes).find(node => node.nodeType === Node.TEXT_NODE && node.textContent.trim());
            if(textNode) textNode.nodeValue = ' Copied!';
            else if (!icon) elementToFeedback.textContent = 'Copied!';


            setTimeout(() => {
                elementToFeedback.className = originalClasses.join(' ');
                if(icon) icon.textContent = originalIcon;
                
                if(textNode) textNode.nodeValue = originalTextContent.replace(originalIcon || '', '').trim();
                else if (!icon && elementToFeedback.textContent === 'Copied!') elementToFeedback.textContent = originalTextContent;

            }, 1500);
        }).catch(err => { showToast('Failed to copy.', 'error', 'error'); console.error('Copy failed: ', err); });
    }
    copyAllMetadataBtn.addEventListener('click', () => {
        if (textToCopy) copyToClipboard(textToCopy, copyAllMetadataBtn);
        else showToast("No metadata content to copy.", "info", "info");
    });

    // --- Main File Processing Logic (Single Image) ---
    function processFile(file) {
        if (!file || !file.type.startsWith('image/')) { showToast('Please select a valid image file.', 'warning', 'warning'); return; }
        
        resetUI(); 
        currentFile = file;

        const reader = new FileReader();
        reader.onload = (e) => {
            originalImageDataUrl = e.target.result;
            imagePreview.src = originalImageDataUrl;
            imagePreview.classList.remove('hidden');
            previewPlaceholder.classList.add('hidden');
            
            stripButton.classList.remove('hidden');
            resetButton.classList.remove('hidden');

            metadataOutput.innerHTML = `<div class="flex flex-col items-center justify-center h-full text-gray-500"><span class="material-symbols-outlined text-4xl animate-spin">progress_activity</span><p class="mt-2 text-sm">Reading metadata...</p></div>`;

            if (file.type === 'image/png') {
                processPng(file);
            } else if (file.type === 'image/jpeg') {
                processJpeg(file, originalImageDataUrl);
            } else { 
                displayBasicInfo(file);
            }
        };
        reader.onerror = () => { showToast('Error reading file.', 'error', 'error'); resetUI(); };
        reader.readAsDataURL(file);
    }

    // --- PNG Metadata Processing ---
    function processPng(file) {
        const fileReader = new FileReader();
        fileReader.onload = (evt) => {
            try {
                const arrayBuffer = evt.target.result; const data = new DataView(arrayBuffer); const pngSignature = [137, 80, 78, 71, 13, 10, 26, 10];
                for (let i = 0; i < 8; i++) { if (data.getUint8(i) !== pngSignature[i]) throw new Error('Invalid PNG signature.'); }
                let offset = 8; const metadata = {};
                while (offset < data.byteLength) {
                    if (offset + 8 > data.byteLength) break; const length = data.getUint32(offset); offset += 4; let type = '';
                    for (let i = 0; i < 4; i++) type += String.fromCharCode(data.getUint8(offset + i)); offset += 4;
                    if (offset + length + 4 > data.byteLength) break;
                    if (type === 'tEXt' || type === 'iTXt' || type === 'zTXt') { 
                        let textBytes = new Uint8Array(arrayBuffer, offset, length);
                        if (type === 'zTXt') {
                            const nullIdx = textBytes.indexOf(0);
                            if (nullIdx !== -1 && textBytes[nullIdx+1] === 0) { 
                                console.warn("zTXt chunk found, decompression not fully implemented without pako.js.");
                                metadata['zTXt_chunk_present (not_decompressed)'] = `Length: ${length}`;
                                offset += length + 4;
                                continue;
                            }
                        }

                        let keyword = '', textValue = ''; const nullIndex = textBytes.indexOf(0);
                        if (nullIndex !== -1) { keyword = new TextDecoder("utf-8").decode(textBytes.slice(0, nullIndex));
                            if (type === 'tEXt') { textValue = new TextDecoder("latin1").decode(textBytes.slice(nullIndex + 1)); }
                            else if (type === 'iTXt') { 
                                const iTXtParts = [];
                                let currentPartStart = nullIndex + 1;
                                for(let i = nullIndex + 1; i < textBytes.length; i++) {
                                    if (textBytes[i] === 0) {
                                        iTXtParts.push(textBytes.slice(currentPartStart, i));
                                        currentPartStart = i + 1;
                                    }
                                }
                                iTXtParts.push(textBytes.slice(currentPartStart));

                                const compressionFlag = iTXtParts[0] ? iTXtParts[0][0] : 0;
                                const actualTextBytes = iTXtParts[4];

                                if (compressionFlag === 0) { 
                                    textValue = new TextDecoder("utf-8").decode(actualTextBytes);
                                } else {
                                    textValue = "[Compressed iTXt data - decompression not supported]";
                                }
                            }
                            if (keyword) metadata[keyword] = textValue;
                        }
                    } offset += length + 4;
                }
                displayPngMetadata(metadata);
                if (Object.keys(metadata).length > 0) {
                    textToCopy = metadata.parameters || Object.entries(metadata).map(([k, v]) => `${k}: ${v}`).join('\n');
                    copyAllMetadataBtn.classList.remove('hidden');
                } else {
                     displayBasicInfo(file, 'No textual metadata chunks found in PNG.');
                }
            } catch (error) {
                console.error("Error processing PNG:", error); showToast(`Error processing file: ${error.message}`, 'error', 'error');
                displayBasicInfo(file, `Failed to parse PNG metadata. ${error.message}`);
            }
        };
        fileReader.readAsArrayBuffer(file);
    }

    // --- JPEG Metadata Processing ---
    function processJpeg(file, imageUrl) {
        const imgForExif = new Image();
        imgForExif.onload = () => {
            EXIF.getData(imgForExif, function() {
                const allTags = EXIF.getAllTags(this);
                displayExifAndBasicInfo(file, allTags);
                if (Object.keys(allTags).length > 0) {
                    textToCopy = Object.entries(allTags).map(([k, v]) => `${k}: ${v}`).join('\n');
                    copyAllMetadataBtn.classList.remove('hidden');
                } else {
                    displayBasicInfo(file, 'No EXIF data found.');
                }
            });
        };
        imgForExif.onerror = () => {
            showToast('Could not load image for EXIF processing.', 'error', 'error');
            displayBasicInfo(file, 'Error loading image for EXIF data extraction.');
        };
        imgForExif.src = imageUrl;
    }

    // --- Metadata Display Functions ---
    function displayBasicInfo(file, message = null) {
        metadataOutput.innerHTML = '';
        const card = document.createElement('div'); card.className = 'metadata-content space-y-6';
        const section = document.createElement('div'); section.className = 'metadata-section';
        section.innerHTML = `<h5 class="text-sm font-semibold text-gray-600 uppercase mb-3 flex items-center gap-1.5"><span class="material-symbols-outlined text-base">info</span>Basic Information</h5>`;
        const container = document.createElement('div'); container.className = 'space-y-1 bg-white p-2 rounded-md border border-gray-200 shadow-sm';
        
        container.appendChild(createParamItem('File Name', file.name));
        container.appendChild(createParamItem('File Type', file.type));
        container.appendChild(createParamItem('File Size', `${(file.size / 1024).toFixed(2)} KB`));
        container.appendChild(createParamItem('Last Modified', new Date(file.lastModified).toLocaleString()));
        
        let statusMessage = message;
        if (!statusMessage) {
            if (file.type === 'image/webp') {
                statusMessage = 'WEBP metadata parsing is limited. Only basic info shown.';
            } else {
                statusMessage = 'No specific AI or EXIF metadata found, or format not fully supported for deep inspection.';
            }
        }
        container.appendChild(createParamItem('Metadata Status', statusMessage, message && message.toLowerCase().includes('error') ? 'text-red-600' : 'text-gray-500'));


        section.appendChild(container);
        card.appendChild(section);
        metadataOutput.appendChild(card);
        textToCopy = `File Name: ${file.name}\nFile Type: ${file.type}\nFile Size: ${(file.size / 1024).toFixed(2)} KB\nLast Modified: ${new Date(file.lastModified).toLocaleString()}\nStatus: ${statusMessage}`;
        copyAllMetadataBtn.classList.remove('hidden');
    }

    function displayExifAndBasicInfo(file, exifData) {
        metadataOutput.innerHTML = '';
        const card = document.createElement('div'); card.className = 'metadata-content space-y-6';
        
        const basicSection = document.createElement('div');
        basicSection.innerHTML = `<h5 class="text-sm font-semibold text-gray-600 uppercase mb-3 flex items-center gap-1.5"><span class="material-symbols-outlined text-base">info</span>Basic Information</h5>`;
        const basicContainer = document.createElement('div'); basicContainer.className = 'space-y-1 bg-white p-2 rounded-md border border-gray-200 shadow-sm';
        basicContainer.appendChild(createParamItem('File Name', file.name));
        basicContainer.appendChild(createParamItem('File Type', file.type));
        basicContainer.appendChild(createParamItem('File Size', `${(file.size / 1024).toFixed(2)} KB`));
        basicSection.appendChild(basicContainer);
        card.appendChild(basicSection);

        if (Object.keys(exifData).length > 0) {
            const exifSection = document.createElement('div');
            exifSection.innerHTML = `<h5 class="text-sm font-semibold text-gray-600 uppercase mb-3 flex items-center gap-1.5"><span class="material-symbols-outlined text-base">camera</span>EXIF Data</h5>`;
            const exifContainer = document.createElement('div'); exifContainer.className = 'space-y-1 bg-white p-2 rounded-md border border-gray-200 shadow-sm';
            
            const commonTags = { "Make": "Camera Make", "Model": "Camera Model", "DateTimeOriginal": "Date/Time Original", "PixelXDimension": "Image Width", "PixelYDimension": "Image Height", "ISOSpeedRatings": "ISO Speed", "ExposureTime": "Exposure Time", "FNumber": "F-Number", "FocalLength": "Focal Length", "GPSLatitude": "GPS Latitude", "GPSLongitude": "GPS Longitude", "Software": "Software", "Artist": "Artist", "Copyright": "Copyright" };
            
            let foundCommonExif = false;
            Object.entries(commonTags).forEach(([key, label]) => {
                if (exifData[key]) {
                    foundCommonExif = true;
                    let value = exifData[key];
                    if (key === "ExposureTime" && typeof value === 'number' && value > 0) value = value < 1 ? `1/${Math.round(1/value)}s` : `${value}s`;
                    if (key === "FNumber" && typeof value === 'object' && value.numerator && value.denominator) value = `f/${(value.numerator / value.denominator).toFixed(1)}`; else if (key === "FNumber") value = `f/${value}`;
                    if ((key === "GPSLatitude" || key === "GPSLongitude") && Array.isArray(value)) value = `${value[0]}Â° ${value[1]}' ${value[2]}" ${exifData[key+"Ref"] || ''}`;
                    exifContainer.appendChild(createParamItem(label, value.toString()));
                }
            });
            if(!foundCommonExif) {
                 exifContainer.appendChild(createParamItem('Status', 'No common EXIF tags found. Raw tags might exist.'));
            }
            exifSection.appendChild(exifContainer);
            card.appendChild(exifSection);
        } else {
            const noExifSection = document.createElement('div');
            noExifSection.innerHTML = `<p class="text-sm text-gray-500 italic mt-4 p-2 bg-white rounded-md border border-gray-200 shadow-sm">No EXIF data found in this image.</p>`;
            card.appendChild(noExifSection);
        }
        metadataOutput.appendChild(card);
    }

    function displayPngMetadata(metadata) {
        metadataOutput.innerHTML = '';
        if (Object.keys(metadata).length === 0) {
            displayBasicInfo(currentFile, 'No PNG textual metadata chunks found.');
            return;
        }
        const metadataCard = document.createElement('div'); metadataCard.className = 'metadata-content space-y-6';

        const basicSection = document.createElement('div');
        basicSection.innerHTML = `<h5 class="text-sm font-semibold text-gray-600 uppercase mb-3 flex items-center gap-1.5"><span class="material-symbols-outlined text-base">info</span>Basic Information</h5>`;
        const basicContainer = document.createElement('div'); basicContainer.className = 'space-y-1 bg-white p-2 rounded-md border border-gray-200 shadow-sm';
        basicContainer.appendChild(createParamItem('File Name', currentFile.name));
        basicContainer.appendChild(createParamItem('File Type', currentFile.type));
        basicContainer.appendChild(createParamItem('File Size', `${(currentFile.size / 1024).toFixed(2)} KB`));
        basicSection.appendChild(basicContainer);
        metadataCard.appendChild(basicSection);


        if (metadata["parameters"]) { 
            let paramText = metadata["parameters"], posPrompt = paramText, negPrompt = "", extraParams = "";
            const negPromptKeyword = "Negative prompt:"; const negIndex = paramText.indexOf(negPromptKeyword);
            if (negIndex !== -1) { 
                posPrompt = paramText.substring(0, negIndex).trim(); 
                const rest = paramText.substring(negIndex + negPromptKeyword.length).trim(); 
                const newlineIndexAfterNeg = rest.indexOf("\n"); 
                if (newlineIndexAfterNeg !== -1) { negPrompt = rest.substring(0, newlineIndexAfterNeg).trim(); extraParams = rest.substring(newlineIndexAfterNeg).trim(); } 
                else { negPrompt = rest; } 
            } else { 
                const firstNewline = paramText.indexOf("\n"); 
                if (firstNewline !== -1) { posPrompt = paramText.substring(0, firstNewline).trim(); extraParams = paramText.substring(firstNewline).trim(); }
                else { posPrompt = paramText.trim(); }
            }

            metadataCard.appendChild(createPromptSection('Positive Prompt', 'palette', posPrompt, 'text-gray-700'));
            if (negPrompt) metadataCard.appendChild(createPromptSection('Negative Prompt', 'block', negPrompt, 'text-red-700'));

            if (extraParams) {
                const genParamsSection = document.createElement('div');
                genParamsSection.className = 'metadata-section';
                genParamsSection.innerHTML = `<h5 class="text-sm font-semibold text-gray-600 uppercase mb-3 flex items-center gap-1.5"><span class="material-symbols-outlined text-base">tune</span>Generation Parameters</h5>`;
                const parsedParams = parseParameters(extraParams);
                if (Object.keys(parsedParams).length > 0) {
                    const paramsGridContainer = document.createElement('div');
                    paramsGridContainer.className = 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 mt-2';
                    Object.entries(parsedParams).forEach(([key, value]) => paramsGridContainer.appendChild(createIndividualParamCard(key, value)));
                    genParamsSection.appendChild(paramsGridContainer);
                } else {
                     genParamsSection.innerHTML += `<p class="text-sm text-gray-500 italic p-2 bg-white rounded-md border">No parsable key-value generation parameters found.</p>`;
                }
                metadataCard.appendChild(genParamsSection);
            }
        }
        const otherMetadata = Object.entries(metadata).filter(([key]) => key !== "parameters");
        if (otherMetadata.length > 0) {
            const additionalSection = document.createElement('div'); additionalSection.className = 'metadata-section pt-4 border-t border-gray-200';
            additionalSection.innerHTML = `<h5 class="text-sm font-semibold text-gray-600 uppercase mb-3 flex items-center gap-1.5"><span class="material-symbols-outlined text-base">label_important</span>Additional Raw Metadata</h5>`;
            const additionalContainer = document.createElement('div'); additionalContainer.className = 'space-y-1 bg-white p-2 rounded-md border border-gray-200 shadow-sm';
            otherMetadata.forEach(([key, value]) => additionalContainer.appendChild(createParamItem(key, value)));
            additionalSection.appendChild(additionalContainer); metadataCard.appendChild(additionalSection);
        }
        metadataOutput.appendChild(metadataCard);
    }

    // --- Metadata Display Helpers ---
    function createParamItem(label, value, valueClass = 'text-gray-700') {
        const item = document.createElement('div');
        item.className = 'flex flex-col sm:flex-row justify-between sm:items-start bg-white rounded-md p-2 mb-1 gap-1 sm:gap-2'; 
        item.innerHTML = `
            <div class="param-label font-medium text-gray-500 text-xs sm:text-sm flex-shrink-0 sm:w-2/5">${label.replace(/_/g, ' ')}:</div>
            <div class="param-value ${valueClass} text-xs sm:text-sm break-all sm:text-right flex-grow">${value}</div>
        `; 
        return item;
    }
    function createPromptSection(title, icon, content, colorClass) {
        const section = document.createElement('div'); section.className = 'metadata-section';
        section.innerHTML = `<h5 class="text-sm font-semibold ${colorClass} uppercase mb-2 flex items-center gap-1.5"><span class="material-symbols-outlined text-base">${icon}</span>${title}</h5>`;
        const pre = document.createElement('pre'); pre.className = 'bg-white border border-gray-200 rounded-lg p-3 text-sm text-gray-700 relative font-sans custom-scrollbar overflow-auto max-h-40'; pre.textContent = content;
        const copyBtn = document.createElement('button'); copyBtn.className = 'copy-btn p-1.5 rounded-full text-gray-400 hover:text-red-600 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-red-500 transition-colors duration-200';
        copyBtn.title = `Copy ${title}`; copyBtn.innerHTML = '<span class="material-symbols-outlined text-base">content_copy</span>'; copyBtn.onclick = (e) => { e.stopPropagation(); copyToClipboard(content, copyBtn); }; pre.appendChild(copyBtn); section.appendChild(pre);
        return section;
    }
    function createIndividualParamCard(label, value) {
        const card = document.createElement('div');
        card.className = 'bg-white border border-gray-200 rounded-lg p-3 shadow-sm flex flex-col gap-1.5 hover:shadow-md transition-shadow duration-150';
        const header = document.createElement('div'); header.className = 'flex justify-between items-center';
        const paramLabel = document.createElement('span'); paramLabel.className = 'text-xs font-semibold text-red-700 uppercase tracking-wider'; paramLabel.textContent = label.replace(/_/g, ' ');
        const copyButton = document.createElement('button'); copyButton.className = 'copy-btn-card p-1 rounded-full text-gray-400 hover:bg-gray-200 hover:text-red-600'; copyButton.title = `Copy ${label}`;
        copyButton.onclick = (e) => { e.stopPropagation(); copyToClipboard(value, copyButton); };
        copyButton.innerHTML = '<span class="material-symbols-outlined text-sm">content_copy</span>';
        header.appendChild(paramLabel); header.appendChild(copyButton);
        const paramValue = document.createElement('div'); paramValue.className = 'text-sm text-gray-700 break-all'; paramValue.textContent = value;
        card.appendChild(header); card.appendChild(paramValue);
        return card;
    }
    function parseParameters(paramsString) {
        const paramsList = {};
        if (!paramsString || typeof paramsString !== 'string') return paramsList;
        const pairs = paramsString.match(/([^:,]+:[^,]+(?:,\s*[^:,]+:[^,]+)*)|([^:,]+:[^,]+)/g) || [];

        paramsString.split(', ').forEach(pair => {
            const colonIndex = pair.indexOf(':');
            if (colonIndex !== -1) {
                const key = pair.substring(0, colonIndex).trim();
                let value = pair.substring(colonIndex + 1).trim();
                if ((value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))) {
                    value = value.substring(1, value.length - 1);
                }
                if (key) paramsList[key] = value;
            }
        });
        return paramsList;
    }

    // --- Metadata Stripping (Single Image) ---
    function stripAndPrepareDownload() {
        if (!originalImageDataUrl || !currentFile) {
            showToast('No image loaded to process.', 'error', 'error');
            return;
        }
        stripButton.disabled = true;
        stripButton.innerHTML = `<span class="material-symbols-outlined animate-spin">progress_activity</span>Processing...`;

        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;

            try {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                let outputType = currentFile.type;
                if (!['image/jpeg', 'image/png', 'image/webp'].includes(outputType)) {
                    outputType = 'image/png'; 
                }
                const cleanedDataUrl = canvas.toDataURL(outputType, 0.95); 

                const baseName = currentFile.name.substring(0, currentFile.name.lastIndexOf('.')) || currentFile.name;
                const extension = outputType.split('/')[1];
                downloadButton.href = cleanedDataUrl;
                downloadButton.download = `${baseName}_cleaned.${extension}`;

                showToast('Metadata stripped! Ready for download.', 'success', 'success');
                stripButton.classList.add('hidden');
                downloadButton.classList.remove('hidden');
                
                metadataOutput.innerHTML = `<div class="flex flex-col items-center justify-center h-full text-green-600 text-center"><span class="material-symbols-outlined text-6xl mb-3">verified_user</span><p class="font-medium">Metadata Stripped Successfully</p><p class="text-sm text-gray-500">Your image is now clean and ready for download.</p></div>`;
                copyAllMetadataBtn.classList.add('hidden');

            } catch (error) {
                 console.error("Canvas drawing error:", error);
                 showToast('Error processing image. It might be too large or corrupted.', 'error', 'error');
                 stripButton.disabled = false; 
                 stripButton.innerHTML = `<span class="material-symbols-outlined">shield</span>Strip Metadata`; 
            }
        };
        img.onerror = () => {
            showToast('Could not load image data for processing.', 'error', 'error');
            stripButton.disabled = false; 
            stripButton.innerHTML = `<span class="material-symbols-outlined">shield</span>Strip Metadata`; 
        };
        img.src = originalImageDataUrl;
    }

    // --- Tab Switching Logic ---
    function initializeTabs() {
        const tabButtons = [
            { btn: singleImageTabBtn, content: singleImageTabContent, id: 'single' },
            { btn: bulkStripTabBtn, content: bulkStripTabContent, id: 'bulk' }
        ];
        let currentActiveTabId = 'single'; // Initial active tab
        let isTransitioning = false;
        const transitionDuration = 300; // ms, should match CSS transition duration

        // Initial setup
        tabButtons.forEach(tab => {
            // Ensure base structural classes are on the tab content elements
            // These define how the content *within* the tab panel behaves (flex, scroll, etc.)
            // The .tab-content class itself is for the transition animation.
            // Example: tab.content.classList.add('flex', 'flex-col', 'flex-grow', 'overflow-hidden');
            // This is already handled by Tailwind classes directly in the HTML for each tab content.

            if (tab.id === currentActiveTabId) {
                tab.content.classList.remove('hidden', 'tab-content-prepared');
                tab.content.classList.add('tab-content-active');
                tab.btn.classList.add('active');
            } else {
                tab.content.classList.add('hidden', 'tab-content-prepared');
                tab.content.classList.remove('tab-content-active');
                tab.btn.classList.remove('active');
            }
        });

        tabButtons.forEach(tab => {
            tab.btn.addEventListener('click', () => {
                if (isTransitioning || tab.id === currentActiveTabId) return;
                isTransitioning = true;

                const newTab = tab;
                const oldTab = tabButtons.find(t => t.id === currentActiveTabId);

                // Animate out current active tab
                if (oldTab) {
                    oldTab.content.classList.remove('tab-content-active');
                    oldTab.content.classList.add('tab-content-prepared'); // This triggers its transition out
                    oldTab.btn.classList.remove('active');
                }

                // Prepare and animate in new tab
                newTab.content.classList.remove('hidden'); // Make it part of layout
                // Ensure it's in the prepared state if it wasn't already (e.g. if JS was interrupted)
                newTab.content.classList.add('tab-content-prepared'); 
                
                // Force reflow to ensure 'prepared' state is rendered before animating to 'active'
                void newTab.content.offsetWidth; 

                requestAnimationFrame(() => {
                    newTab.content.classList.remove('tab-content-prepared');
                    newTab.content.classList.add('tab-content-active'); // This triggers its transition in
                });
                newTab.btn.classList.add('active');
                
                // After transition duration, add 'hidden' to the old tab
                setTimeout(() => {
                    if (oldTab) {
                        oldTab.content.classList.add('hidden');
                    }
                    isTransitioning = false;
                }, transitionDuration);
                
                currentActiveTabId = newTab.id;
            });
        });
    }


    // --- Bulk Processing Logic ---
    function resetBulkUI() {
        bulkFilesData = [];
        nextBulkFileId = 0;
        bulkFileInput.value = '';
        renderBulkImageList();
        stripAllBulkButton.disabled = true;
        downloadAllCleanedBulkButton.disabled = true;
        stripAllBulkButton.innerHTML = `<span class="material-symbols-outlined">auto_fix_high</span>Strip All Metadata`;
    }

    function addFilesToBulkQueue(files) {
        bulkPlaceholder.classList.add('hidden');
        bulkImageListHeader.classList.remove('hidden');

        for (const file of files) {
            if (!file.type.startsWith('image/')) {
                showToast(`Skipping non-image file: ${file.name}`, 'warning', 'warning');
                continue;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                bulkFilesData.push({
                    id: nextBulkFileId++,
                    file: file,
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    status: 'Pending', 
                    originalSrc: e.target.result,
                    cleanedSrc: null,
                    error: null
                });
                renderBulkImageList();
                stripAllBulkButton.disabled = false;
            };
            reader.readAsDataURL(file);
        }
    }

    function renderBulkImageList() {
        bulkImageList.innerHTML = '';
        if (bulkFilesData.length === 0) {
            bulkPlaceholder.classList.remove('hidden');
            bulkImageListHeader.classList.add('hidden');
            stripAllBulkButton.disabled = true;
            downloadAllCleanedBulkButton.disabled = true;
            return;
        }

        bulkFilesData.forEach(item => {
            const div = document.createElement('div');
            div.className = 'bulk-image-item grid grid-cols-[60px_1fr_100px_120px_100px] gap-2 items-center p-2 border-b border-gray-100 hover:bg-gray-100 transition-colors duration-150';
            div.dataset.fileId = item.id;

            let statusColor = 'text-gray-500';
            let statusIcon = 'hourglass_empty';
            if (item.status === 'Stripping') { statusColor = 'text-blue-500'; statusIcon = 'progress_activity animate-spin'; }
            else if (item.status === 'Stripped') { statusColor = 'text-green-600'; statusIcon = 'check_circle'; }
            else if (item.status === 'Error') { statusColor = 'text-red-600'; statusIcon = 'error'; }

            div.innerHTML = `
                <img src="${item.originalSrc}" alt="${item.name}" class="w-10 h-10 object-cover rounded border border-gray-200">
                <div class="filename text-sm text-gray-700 truncate" title="${item.name}">${item.name}</div>
                <div class="filesize text-xs text-gray-500 text-center">${(item.size / 1024).toFixed(1)} KB</div>
                <div class="status ${statusColor} text-xs font-medium flex items-center justify-center gap-1">
                    <span class="material-symbols-outlined text-sm">${statusIcon}</span>
                    ${item.status}
                </div>
                <div class="action text-center">
                    ${item.status === 'Stripped' && item.cleanedSrc ? 
                        `<a href="${item.cleanedSrc}" download="${item.name.substring(0, item.name.lastIndexOf('.')) || item.name}_cleaned.${item.type.split('/')[1]}" class="text-green-600 hover:text-green-700 text-xs font-semibold inline-flex items-center gap-1">
                            <span class="material-symbols-outlined text-sm">download</span>Download
                         </a>` : 
                         item.status === 'Error' ? `<span class="text-red-500 text-xs" title="${item.error}">Failed</span>` :
                         `<span class="text-gray-400 text-xs">-</span>`
                    }
                </div>
            `;
            bulkImageList.appendChild(div);
        });
        
        const anyStripped = bulkFilesData.some(f => f.status === 'Stripped');
        downloadAllCleanedBulkButton.disabled = !anyStripped;
    }

    async function stripSingleBulkImage(fileData) {
        fileData.status = 'Stripping';
        fileData.error = null;
        renderBulkImageList();

        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;

                try {
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    let outputType = fileData.type;
                    if (!['image/jpeg', 'image/png', 'image/webp'].includes(outputType)) {
                        outputType = 'image/png';
                    }
                    fileData.cleanedSrc = canvas.toDataURL(outputType, 0.95);
                    fileData.status = 'Stripped';
                } catch (e) {
                    console.error(`Error stripping ${fileData.name}:`, e);
                    fileData.status = 'Error';
                    fileData.error = e.message || 'Canvas processing failed.';
                }
                renderBulkImageList();
                resolve();
            };
            img.onerror = () => {
                fileData.status = 'Error';
                fileData.error = 'Could not load image data.';
                renderBulkImageList();
                resolve();
            };
            img.src = fileData.originalSrc;
        });
    }

    async function handleStripAllBulk() {
        if (bulkFilesData.length === 0 || bulkFilesData.every(f => f.status !== 'Pending')) {
            showToast('No pending images to strip.', 'info', 'info');
            return;
        }
        stripAllBulkButton.disabled = true;
        stripAllBulkButton.innerHTML = `<span class="material-symbols-outlined animate-spin">progress_activity</span>Stripping...`;

        for (const fileDataItem of bulkFilesData) {
            if (fileDataItem.status === 'Pending') {
                await stripSingleBulkImage(fileDataItem);
            }
        }
        
        stripAllBulkButton.innerHTML = `<span class="material-symbols-outlined">auto_fix_high</span>Strip All Metadata`;
        const hasPending = bulkFilesData.some(f => f.status === 'Pending' || f.status === 'Error');
        stripAllBulkButton.disabled = !hasPending && bulkFilesData.length > 0;


        const successCount = bulkFilesData.filter(f => f.status === 'Stripped').length;
        const errorCount = bulkFilesData.filter(f => f.status === 'Error').length;
        if (successCount > 0) showToast(`${successCount} image(s) stripped successfully.`, 'success', 'success');
        if (errorCount > 0) showToast(`${errorCount} image(s) failed to strip.`, 'error', 'error');
        if (successCount === 0 && errorCount === 0 && bulkFilesData.length > 0) showToast('No images were processed.', 'info', 'info');
    }
    
    function handleDownloadAllCleanedBulk() {
        const cleanedFiles = bulkFilesData.filter(f => f.status === 'Stripped' && f.cleanedSrc);
        if (cleanedFiles.length === 0) {
            showToast('No cleaned images available for download.', 'info', 'info');
            return;
        }

        cleanedFiles.forEach((fileData, index) => {
            setTimeout(() => { 
                const a = document.createElement('a');
                a.href = fileData.cleanedSrc;
                a.download = `${fileData.name.substring(0, fileData.name.lastIndexOf('.')) || fileData.name}_cleaned.${fileData.type.split('/')[1]}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }, index * 300);
        });
        showToast(`Downloading ${cleanedFiles.length} cleaned image(s)...`, 'download', 'info');
    }

    function handleClearBulkQueue() {
        resetBulkUI();
        showToast('Image queue cleared.', 'delete_sweep', 'info');
    }


    // --- Event Listeners ---
    fileInput.addEventListener('change', (e) => { if (e.target.files.length > 0) processFile(e.target.files[0]); });
    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
    dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); });
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); if (e.dataTransfer.files.length > 0) processFile(e.dataTransfer.files[0]); });
    
    document.addEventListener('paste', (e) => {
        if (singleImageTabContent.classList.contains('tab-content-active')) { // Check if single image tab is active
            const file = e.clipboardData?.files[0];
            if (file && file.type.startsWith('image/')) {
                showToast('Pasted image!', 'add_photo_alternate', 'info');
                processFile(file);
            }
        }
    });
    stripButton.addEventListener('click', stripAndPrepareDownload);
    resetButton.addEventListener('click', resetUI);

    // Bulk Tab Event Listeners
    bulkFileInput.addEventListener('change', (e) => { if (e.target.files.length > 0) addFilesToBulkQueue(e.target.files); });
    bulkDropZone.addEventListener('click', () => bulkFileInput.click());
    bulkDropZone.addEventListener('dragover', (e) => { e.preventDefault(); bulkDropZone.classList.add('dragover'); });
    bulkDropZone.addEventListener('dragleave', (e) => { e.preventDefault(); bulkDropZone.classList.remove('dragover'); });
    bulkDropZone.addEventListener('drop', (e) => { e.preventDefault(); bulkDropZone.classList.remove('dragover'); if (e.dataTransfer.files.length > 0) addFilesToBulkQueue(e.dataTransfer.files); });
    
    stripAllBulkButton.addEventListener('click', handleStripAllBulk);
    downloadAllCleanedBulkButton.addEventListener('click', handleDownloadAllCleanedBulk);
    clearBulkQueueButton.addEventListener('click', handleClearBulkQueue);


    // --- Initial State ---
    resetUI();
    initializeTabs(); // This will set up initial tab states and transitions
    resetBulkUI(); 

  </script>
</body>
</html>