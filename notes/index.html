<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <title>NOTES</title>

    <style>
        :root {
            --bg-color-light: #f8f9fa;
            --text-color-light: #212529;
            --card-bg-light: rgba(255, 255, 255, 0.75); /* Slightly less transparent for readability */
            --card-border-light: rgba(0, 0, 0, 0.1);
            --toolbar-bg-light: rgba(255, 255, 255, 0.9);
            --toolbar-shadow-light: 0 4px 12px rgba(0, 0, 0, 0.1);
            --grid-color-light: rgba(0, 0, 0, 0.08);
            --icon-color-light: #343A40;
            --accent-color: #FFD700;
            --accent-text-color: #333;
            --placeholder-color-light: #6c757d;

            --bg-color-dark: #1a1c1e;
            --text-color-dark: #e0e0e0;
            --card-bg-dark: rgba(40, 42, 44, 0.75);
            --card-border-dark: rgba(255, 255, 255, 0.1);
            --toolbar-bg-dark: rgba(30, 32, 34, 0.9);
            --toolbar-shadow-dark: 0 4px 12px rgba(0, 0, 0, 0.3);
            --grid-color-dark: rgba(255, 255, 255, 0.08);
            --icon-color-dark: #E0E0E0;
            --placeholder-color-dark: #868e96;
        }

        html { font-family: 'Poppins', sans-serif; }
        body {
            background-color: var(--bg-color-light); color: var(--text-color-light);
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow: hidden; margin: 0; padding: 0;
        }
        html.dark body { background-color: var(--bg-color-dark); color: var(--text-color-dark); }

        #canvas-container {
            width: 100vw; height: 100vh; position: relative; overflow: hidden;
            cursor: grab; transition: background-image 0.3s ease;
        }
        .grid-visible {
            background-image:
                linear-gradient(to right, var(--grid-color-light) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color-light) 1px, transparent 1px);
            background-size: 20px 20px; /* GRID_SIZE */
        }
        html.dark .grid-visible {
             background-image:
                linear-gradient(to right, var(--grid-color-dark) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color-dark) 1px, transparent 1px);
        }
        #canvas { position: absolute; transform-origin: 0 0; width: 1px; height: 1px; }

        .note {
            position: absolute;
            background-color: var(--card-bg-light); border: 1px solid var(--card-border-light);
            border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            padding: 0; /* Padding will be on inner elements */
            cursor: move; display: flex; flex-direction: column;
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            transition: box-shadow 0.2s ease-out, background-color 0.3s ease, border-color 0.3s ease;
            overflow: hidden;
        }
        html.dark .note {
            background-color: var(--card-bg-dark); border: 1px solid var(--card-border-dark);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .note:hover { box-shadow: 0 6px 16px rgba(0,0,0,0.12); }
        html.dark .note:hover { box-shadow: 0 6px 16px rgba(0,0,0,0.3); }
        .note.selected {
            box-shadow: 0 0 0 3px var(--accent-color), 0 6px 16px rgba(0,0,0,0.15);
            border-color: var(--accent-color);
        }
        html.dark .note.selected {
            box-shadow: 0 0 0 3px var(--accent-color), 0 6px 16px rgba(0,0,0,0.35);
        }

        .note-header {
            display: flex; align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            flex-shrink: 0;
        }
        html.dark .note-header { border-bottom: 1px solid rgba(255,255,255,0.05); }

        .note-title {
            flex-grow: 1; font-weight: 600; font-size: 16px;
            outline: none; color: var(--text-color-light);
        }
        html.dark .note-title { color: var(--text-color-dark); }
        .note-title:empty:before {
            content: attr(placeholder);
            color: var(--placeholder-color-light);
            font-weight: 500;
        }
        html.dark .note-title:empty:before { color: var(--placeholder-color-dark); }


        .note-color-picker {
            width: 16px; height: 16px; border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.2); cursor: pointer;
            margin-left: 8px; opacity: 0; transition: opacity 0.2s ease;
            flex-shrink: 0;
        }
        .note:hover .note-color-picker, .note.selected .note-color-picker { opacity: 1; }

        .note-content-wrapper { /* New wrapper for padding and scroll */
            flex-grow: 1;
            padding: 12px;
            overflow-y: auto;
        }

        .note-content {
            outline: none; font-size: 14px; line-height: 1.7; /* Increased line height */
            color: var(--text-color-light);
            min-height: 40px; /* Minimum height for the content area itself */
        }
        html.dark .note-content { color: var(--text-color-dark); }
        .note-content:empty:before {
            content: attr(placeholder);
            color: var(--placeholder-color-light);
            pointer-events: none; display: block;
        }
        html.dark .note-content:empty:before { color: var(--placeholder-color-dark); }

        /* Checklist styles */
        .checklist-item { display: flex; align-items: flex-start; margin-bottom: 6px; }
        .checklist-item input[type="checkbox"] {
            margin-right: 8px; margin-top: 5px; /* Align with text better */
            flex-shrink: 0;
            width: 16px; height: 16px;
            accent-color: var(--accent-color); /* Style checkbox color */
        }
        .checklist-item span {
            flex-grow: 1; outline: none;
        }
        .checklist-item input[type="checkbox"]:checked + span {
            text-decoration: line-through;
            color: gray;
        }

        /* Markdown-like element styling */
        .note-content h1, .note-content h2, .note-content h3 { margin-top: 0.5em; margin-bottom: 0.25em; font-weight: 600; }
        .note-content h1 { font-size: 1.5em; }
        .note-content h2 { font-size: 1.3em; }
        .note-content h3 { font-size: 1.15em; }
        .note-content a { color: var(--accent-color); text-decoration: underline; }
        html.dark .note-content a { color: var(--accent-color); } /* Ensure accent is visible in dark mode */
        .note-content ul, .note-content ol { margin-left: 20px; padding-left: 5px; }
        .note-content blockquote {
            border-left: 3px solid var(--accent-color);
            margin-left: 0; padding-left: 1em; color: gray; font-style: italic;
        }
        .note-content pre {
            background-color: rgba(0,0,0,0.05);
            padding: 10px; border-radius: 6px;
            overflow-x: auto; font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em; margin: 0.5em 0;
        }
        html.dark .note-content pre { background-color: rgba(255,255,255,0.05); }
        .note-content code { /* Inline code */
            background-color: rgba(0,0,0,0.05);
            padding: 2px 4px; border-radius: 4px;
            font-family: 'Courier New', Courier, monospace; font-size: 0.9em;
        }
        html.dark .note-content code { background-color: rgba(255,255,255,0.05); }
        .note-content pre code { /* Reset for code inside pre */
            background-color: transparent; padding: 0; border-radius: 0;
        }


        .note-resize-handle {
            position: absolute; bottom: 1px; right: 1px;
            width: 20px; height: 20px; cursor: nwse-resize;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; transition: opacity 0.2s ease; z-index: 10;
        }
        .note.selected .note-resize-handle { opacity: 0.7; }
        .note.selected .note-resize-handle:hover { opacity: 1; }
        .note-resize-handle .material-symbols-outlined { font-size: 18px; color: var(--icon-color-light); }
        html.dark .note-resize-handle .material-symbols-outlined { color: var(--icon-color-dark); }

        #toolbar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: var(--toolbar-bg-light); padding: 8px 10px; /* Adjusted padding */
            border-radius: 16px; box-shadow: var(--toolbar-shadow-light);
            display: flex; flex-wrap: wrap; /* Allow wrapping for more buttons */
            gap: 5px; /* Adjusted gap */
            align-items: center; z-index: 1000;
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            max-width: 90vw; /* Prevent toolbar from being too wide */
            justify-content: center;
        }
        html.dark #toolbar { background-color: var(--toolbar-bg-dark); box-shadow: var(--toolbar-shadow-dark); }

        .toolbar-button {
            background-color: transparent; border: none; padding: 7px; /* Adjusted padding */
            border-radius: 8px; cursor: pointer; display: flex;
            align-items: center; justify-content: center;
            color: var(--icon-color-light);
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        html.dark .toolbar-button { color: var(--icon-color-dark); }
        .toolbar-button:hover { background-color: rgba(0,0,0,0.05); }
        html.dark .toolbar-button:hover { background-color: rgba(255,255,255,0.1); }
        .toolbar-button.active { background-color: var(--accent-color); color: var(--accent-text-color); }
        .toolbar-button:disabled { opacity: 0.5; cursor: not-allowed; }
        .toolbar-button:disabled:hover { background-color: transparent; }
        .toolbar-separator { width: 1px; height: 24px; background-color: rgba(0,0,0,0.1); margin: 0 4px; }
        html.dark .toolbar-separator { background-color: rgba(255,255,255,0.1); }


        .material-symbols-outlined { font-size: 20px; /* Slightly smaller default for toolbar */ }

        .color-palette {
            position: fixed; /* Use fixed for palette too */
            background-color: var(--toolbar-bg-light); border: 1px solid var(--card-border-light);
            border-radius: 8px; padding: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex; gap: 6px; z-index: 1001;
        }
        html.dark .color-palette {
            background-color: var(--toolbar-bg-dark); border: 1px solid var(--card-border-dark);
        }
        .color-option {
            width: 20px; height: 20px; border-radius: 50%; cursor: pointer;
            border: 1px solid rgba(0,0,0,0.1);
        }
        html.dark .color-option { border: 1px solid rgba(255,255,255,0.1); }

        .note-content::-webkit-scrollbar { width: 8px; }
        .note-content::-webkit-scrollbar-track { background: transparent; }
        .note-content::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 4px; }
        html.dark .note-content::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.2); }
        .note-content::-webkit-scrollbar-thumb:hover { background-color: rgba(0,0,0,0.3); }
        html.dark .note-content::-webkit-scrollbar-thumb:hover { background-color: rgba(255,255,255,0.3); }
    </style>
</head>
<body>

    <div id="canvas-container">
        <div id="canvas"></div>
    </div>

    <div id="toolbar">
        <button id="addNoteBtn" class="toolbar-button" title="Add Note"><span class="material-symbols-outlined">add_circle</span></button>
        <button id="deleteNoteBtn" class="toolbar-button" title="Delete Selected Note" disabled><span class="material-symbols-outlined">delete</span></button>
        <div class="toolbar-separator"></div>
        <button id="zoomInBtn" class="toolbar-button" title="Zoom In"><span class="material-symbols-outlined">zoom_in</span></button>
        <button id="zoomOutBtn" class="toolbar-button" title="Zoom Out"><span class="material-symbols-outlined">zoom_out</span></button>
        <button id="resetZoomBtn" class="toolbar-button" title="Reset View"><span class="material-symbols-outlined">center_focus_strong</span></button>
        <div class="toolbar-separator"></div>
        <button id="boldBtn" class="toolbar-button" title="Bold (Ctrl+B)"><span class="material-symbols-outlined">format_bold</span></button>
        <button id="italicBtn" class="toolbar-button" title="Italic (Ctrl+I)"><span class="material-symbols-outlined">format_italic</span></button>
        <button id="underlineBtn" class="toolbar-button" title="Underline (Ctrl+U)"><span class="material-symbols-outlined">format_underlined</span></button>
        <button id="strikethroughBtn" class="toolbar-button" title="Strikethrough"><span class="material-symbols-outlined">format_strikethrough</span></button>
        <button id="linkBtn" class="toolbar-button" title="Create Link"><span class="material-symbols-outlined">link</span></button>
        <div class="toolbar-separator"></div>
        <button id="h1Btn" class="toolbar-button" title="Heading 1"><span class="material-symbols-outlined">format_h1</span></button>
        <button id="h2Btn" class="toolbar-button" title="Heading 2"><span class="material-symbols-outlined">format_h2</span></button>
        <button id="h3Btn" class="toolbar-button" title="Heading 3"><span class="material-symbols-outlined">format_h3</span></button>
        <button id="ulBtn" class="toolbar-button" title="Unordered List"><span class="material-symbols-outlined">format_list_bulleted</span></button>
        <button id="olBtn" class="toolbar-button" title="Ordered List"><span class="material-symbols-outlined">format_list_numbered</span></button>
        <button id="checklistBtn" class="toolbar-button" title="Checklist Item"><span class="material-symbols-outlined">checklist</span></button>
        <button id="quoteBtn" class="toolbar-button" title="Blockquote"><span class="material-symbols-outlined">format_quote</span></button>
        <button id="inlineCodeBtn" class="toolbar-button" title="Inline Code"><span class="material-symbols-outlined">code</span></button>
        <button id="codeBlockBtn" class="toolbar-button" title="Code Block"><span class="material-symbols-outlined">code_blocks</span></button>
        <div class="toolbar-separator"></div>
        <button id="toggleGridBtn" class="toolbar-button" title="Toggle Grid"><span class="material-symbols-outlined">grid_on</span></button>
        <button id="toggleThemeBtn" class="toolbar-button" title="Toggle Theme"><span class="material-symbols-outlined">brightness_6</span></button>
    </div>

    <script>
        // DOM Elements
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('canvas');
        const toolbar = document.getElementById('toolbar');
        // Toolbar Buttons (dynamically get all formatting buttons later)
        const addNoteBtn = document.getElementById('addNoteBtn');
        const deleteNoteBtn = document.getElementById('deleteNoteBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        const toggleGridBtn = document.getElementById('toggleGridBtn');
        const toggleThemeBtn = document.getElementById('toggleThemeBtn');
        // Formatting buttons
        const formattingButtons = {
            bold: document.getElementById('boldBtn'),
            italic: document.getElementById('italicBtn'),
            underline: document.getElementById('underlineBtn'),
            strikethrough: document.getElementById('strikethroughBtn'),
            link: document.getElementById('linkBtn'),
            h1: document.getElementById('h1Btn'),
            h2: document.getElementById('h2Btn'),
            h3: document.getElementById('h3Btn'),
            ul: document.getElementById('ulBtn'),
            ol: document.getElementById('olBtn'),
            checklist: document.getElementById('checklistBtn'),
            quote: document.getElementById('quoteBtn'),
            inlineCode: document.getElementById('inlineCodeBtn'),
            codeBlock: document.getElementById('codeBlockBtn'),
        };

        // State
        let notes = [];
        let selectedNoteId = null;
        let highestZIndex = 1;
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastPanX, lastPanY;
        let isDraggingNote = false;
        let isResizingNote = false;
        let dragOffsetX, dragOffsetY;
        let initialResizeMouseX, initialResizeMouseY, initialNoteWidth, initialNoteHeight;

        // Constants
        const GRID_SIZE = 20;
        const MIN_NOTE_WIDTH = GRID_SIZE * 5; // 100px
        const MIN_NOTE_HEIGHT = GRID_SIZE * 4; // 80px
        const NOTE_COLORS = [ /* ... same as before ... */ ];
        const DARK_NOTE_COLORS = [ /* ... same as before ... */ ];
        // (Copy NOTE_COLORS and DARK_NOTE_COLORS from previous version)
        NOTE_COLORS.push(...[
            'rgba(255, 215, 0, 0.7)', 'rgba(173, 216, 230, 0.7)', 'rgba(144, 238, 144, 0.7)',
            'rgba(255, 182, 193, 0.7)', 'rgba(221, 160, 221, 0.7)', 'rgba(240, 240, 240, 0.7)'
        ]);
        DARK_NOTE_COLORS.push(...[
            'rgba(255, 215, 0, 0.6)', 'rgba(70, 130, 180, 0.6)', 'rgba(60, 179, 113, 0.6)',
            'rgba(219, 112, 147, 0.6)', 'rgba(147, 112, 219, 0.6)', 'rgba(60, 60, 60, 0.7)'
        ]);


        // --- Utility Functions ---
        function snapToGrid(value, gridSize = GRID_SIZE) { return Math.round(value / gridSize) * gridSize; }
        
        function getSelectedNoteContentElement() {
            if (!selectedNoteId) return null;
            const noteEl = canvas.querySelector(`.note[data-id="${selectedNoteId}"]`);
            return noteEl ? noteEl.querySelector('.note-content') : null;
        }

        // --- Initialization ---
        function init() {
            loadState();
            updateCanvasTransform();
            renderNotes();
            updateToolbarState();
            applyTheme(localStorage.getItem('modularNotepad_theme_v4') || 'light');
            applyGridVisibility(localStorage.getItem('modularNotepad_gridVisible_v4') === 'true');

            canvasContainer.addEventListener('mousedown', handleCanvasMouseDown);
            canvasContainer.addEventListener('wheel', handleCanvasWheel, { passive: false });
            document.addEventListener('mousemove', handleGlobalMouseMove);
            document.addEventListener('mouseup', handleGlobalMouseUp);

            setupToolbarButtonListeners();
            document.addEventListener('selectionchange', updateFormattingButtonStates);
            document.addEventListener('click', handleDocumentClickForDeselectionAndPalette); // Consolidated
        }

        function setupToolbarButtonListeners() {
            addNoteBtn.addEventListener('click', addNote);
            deleteNoteBtn.addEventListener('click', deleteSelectedNote);
            zoomInBtn.addEventListener('click', () => zoomViaButton(1.2));
            zoomOutBtn.addEventListener('click', () => zoomViaButton(1 / 1.2));
            resetZoomBtn.addEventListener('click', resetView);
            toggleGridBtn.addEventListener('click', toggleGrid);
            toggleThemeBtn.addEventListener('click', toggleTheme);

            // Formatting buttons
            formattingButtons.bold.addEventListener('click', () => execCmd('bold'));
            formattingButtons.italic.addEventListener('click', () => execCmd('italic'));
            formattingButtons.underline.addEventListener('click', () => execCmd('underline'));
            formattingButtons.strikethrough.addEventListener('click', () => execCmd('strikeThrough'));
            formattingButtons.link.addEventListener('click', createLink);
            formattingButtons.h1.addEventListener('click', () => execCmdFormatBlock('h1'));
            formattingButtons.h2.addEventListener('click', () => execCmdFormatBlock('h2'));
            formattingButtons.h3.addEventListener('click', () => execCmdFormatBlock('h3'));
            formattingButtons.ul.addEventListener('click', () => execCmd('insertUnorderedList'));
            formattingButtons.ol.addEventListener('click', () => execCmd('insertOrderedList'));
            formattingButtons.checklist.addEventListener('click', insertChecklistItem);
            formattingButtons.quote.addEventListener('click', () => execCmdFormatBlock('blockquote'));
            formattingButtons.inlineCode.addEventListener('click', insertInlineCode);
            formattingButtons.codeBlock.addEventListener('click', insertCodeBlock);
        }

        // --- Theme & Grid --- (Mostly same as before, ensure keys are updated for localStorage if needed)
        function applyTheme(theme) {
            document.documentElement.classList.toggle('dark', theme === 'dark');
            toggleThemeBtn.querySelector('.material-symbols-outlined').textContent = theme === 'dark' ? 'light_mode' : 'dark_mode';
            localStorage.setItem('modularNotepad_theme_v4', theme);
        }
        function toggleTheme() { applyTheme(document.documentElement.classList.contains('dark') ? 'light' : 'dark'); }
        function applyGridVisibility(visible) {
            canvasContainer.classList.toggle('grid-visible', visible);
            toggleGridBtn.classList.toggle('active', visible);
            localStorage.setItem('modularNotepad_gridVisible_v4', visible);
        }
        function toggleGrid() { applyGridVisibility(!canvasContainer.classList.contains('grid-visible')); }

        // --- Canvas Interaction (Zoom & Pan) --- (Mostly same as before)
        function updateCanvasTransform() { canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`; }
        function zoomAtPoint(mouseX, mouseY, factor) {
            const mouseBeforeZoomX = (mouseX - panX) / zoomLevel;
            const mouseBeforeZoomY = (mouseY - panY) / zoomLevel;
            zoomLevel = Math.max(0.1, Math.min(zoomLevel * factor, 5));
            panX = mouseX - mouseBeforeZoomX * zoomLevel;
            panY = mouseY - mouseBeforeZoomY * zoomLevel;
            updateCanvasTransform(); saveState();
        }
        function zoomViaButton(factor) {
            const rect = canvasContainer.getBoundingClientRect();
            zoomAtPoint(rect.width / 2, rect.height / 2, factor);
        }
        function resetView() { zoomLevel = 1; panX = 0; panY = 0; updateCanvasTransform(); saveState(); }
        function handleCanvasMouseDown(e) {
            if (e.target === canvasContainer || e.target === canvas) {
                isPanning = true; canvasContainer.style.cursor = 'grabbing';
                lastPanX = e.clientX; lastPanY = e.clientY;
                // Deselection is handled by global click listener now
            }
        }
        // handleCanvasMouseMove for panning is removed, integrated into handleGlobalMouseMove
        function handleCanvasWheel(e) {
            e.preventDefault();
            const deltaFactor = e.deltaY > 0 ? 1 / 1.1 : 1.1;
            const rect = canvasContainer.getBoundingClientRect();
            zoomAtPoint(e.clientX - rect.left, e.clientY - rect.top, deltaFactor);
        }

        // --- Note Element Creation & Management ---
        function createNoteElement(note) {
            const noteEl = document.createElement('div');
            noteEl.className = 'note';
            noteEl.dataset.id = note.id;
            Object.assign(noteEl.style, {
                left: `${note.x}px`, top: `${note.y}px`,
                width: `${note.width}px`, height: `${note.height}px`,
                zIndex: note.zIndex, backgroundColor: note.color
            });
            if (note.id === selectedNoteId) noteEl.classList.add('selected');

            // Header
            const headerEl = document.createElement('div');
            headerEl.className = 'note-header';
            const titleEl = document.createElement('div');
            titleEl.className = 'note-title';
            titleEl.setAttribute('contenteditable', 'true');
            titleEl.setAttribute('placeholder', 'Title');
            titleEl.innerHTML = note.title || '';
            titleEl.addEventListener('input', () => { note.title = titleEl.innerHTML; saveState(); });
            titleEl.addEventListener('blur', () => { note.title = titleEl.innerHTML; saveState(); }); // Ensure save on blur
            titleEl.addEventListener('keydown', (e) => { // Prevent new line in title
                if (e.key === 'Enter') e.preventDefault();
            });


            const colorPickerInput = document.createElement('input');
            colorPickerInput.type = 'button';
            colorPickerInput.className = 'note-color-picker';
            colorPickerInput.title = "Change note color";
            colorPickerInput.style.backgroundColor = note.color || (document.documentElement.classList.contains('dark') ? DARK_NOTE_COLORS[5] : NOTE_COLORS[5]);
            colorPickerInput.addEventListener('click', (e) => { e.stopPropagation(); showColorPalette(e.target, note.id); });
            
            headerEl.appendChild(titleEl);
            headerEl.appendChild(colorPickerInput);

            // Content Wrapper & Content
            const contentWrapperEl = document.createElement('div');
            contentWrapperEl.className = 'note-content-wrapper';
            const contentEl = document.createElement('div');
            contentEl.className = 'note-content';
            contentEl.setAttribute('contenteditable', 'true');
            contentEl.setAttribute('placeholder', 'Start typing...');
            contentEl.innerHTML = note.content;
            contentEl.addEventListener('focus', () => { selectNote(note.id); updateFormattingButtonStates(); });
            contentEl.addEventListener('blur', () => { note.content = contentEl.innerHTML; saveState(); });
            contentEl.addEventListener('input', () => { note.content = contentEl.innerHTML; saveStateDebounced(); });
            // Handle checklist item interaction
            contentEl.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox' && e.target.closest('.checklist-item')) {
                    // The checked state is already part of the innerHTML.
                    // We just need to ensure the note's content is updated in our data model.
                    note.content = contentEl.innerHTML;
                    saveState(); // Save immediately on checkbox change
                }
            });


            contentWrapperEl.appendChild(contentEl);

            // Resize Handle
            const resizeHandleEl = document.createElement('div');
            resizeHandleEl.className = 'note-resize-handle';
            resizeHandleEl.innerHTML = `<span class="material-symbols-outlined">aspect_ratio</span>`;

            noteEl.append(headerEl, contentWrapperEl, resizeHandleEl);

            // Event listeners for drag/resize initiation
            noteEl.addEventListener('mousedown', (e) => {
                if (e.target.closest('.note-title') || e.target.closest('.note-content') || e.target.closest('.note-color-picker') || e.target.closest('.note-resize-handle') || e.target.closest('input[type="checkbox"]') || e.target.closest('a')) {
                    if (!noteEl.classList.contains('selected')) selectNote(note.id);
                    return;
                }
                e.stopPropagation(); isDraggingNote = true; selectNote(note.id);
                noteEl.style.cursor = 'grabbing'; canvasContainer.style.cursor = 'grabbing';
                const noteRect = noteEl.getBoundingClientRect();
                dragOffsetX = (e.clientX - noteRect.left) / zoomLevel;
                dragOffsetY = (e.clientY - noteRect.top) / zoomLevel;
                bringToFront(note.id);
            });
            resizeHandleEl.addEventListener('mousedown', (e) => {
                e.stopPropagation(); isResizingNote = true; selectNote(note.id);
                noteEl.style.cursor = 'nwse-resize'; canvasContainer.style.cursor = 'nwse-resize';
                initialResizeMouseX = (e.clientX - panX) / zoomLevel;
                initialResizeMouseY = (e.clientY - panY) / zoomLevel;
                initialNoteWidth = parseFloat(noteEl.style.width);
                initialNoteHeight = parseFloat(noteEl.style.height);
                bringToFront(note.id);
            });
            return noteEl;
        }

        function bringToFront(noteId) {
            const note = notes.find(n => n.id === noteId);
            const noteEl = canvas.querySelector(`.note[data-id="${noteId}"]`);
            if (note && noteEl && (note.zIndex < highestZIndex || notes.filter(n => n.zIndex === note.zIndex).length > 1 && note.zIndex !== highestZIndex)) {
                highestZIndex++;
                note.zIndex = highestZIndex;
                noteEl.style.zIndex = note.zIndex;
                // saveState(); // Saved on mouseup of drag/resize
            }
        }
        
        // --- Global Mouse Move & Up Handlers (for drag, resize, pan) ---
        function handleGlobalMouseMove(e) {
            if (isPanning) { // Canvas Panning
                const dx = e.clientX - lastPanX; const dy = e.clientY - lastPanY;
                panX += dx; panY += dy;
                lastPanX = e.clientX; lastPanY = e.clientY;
                updateCanvasTransform(); // No save here, on mouseup
            } else if (isDraggingNote && selectedNoteId) { // Note Dragging
                const noteEl = canvas.querySelector(`.note[data-id="${selectedNoteId}"]`);
                if (!noteEl) return;
                let newX = (e.clientX - panX) / zoomLevel - dragOffsetX;
                let newY = (e.clientY - panY) / zoomLevel - dragOffsetY;
                noteEl.style.left = `${newX}px`; noteEl.style.top = `${newY}px`;
            } else if (isResizingNote && selectedNoteId) { // Note Resizing
                const noteEl = canvas.querySelector(`.note[data-id="${selectedNoteId}"]`);
                if (!noteEl) return;
                const currentMouseX = (e.clientX - panX) / zoomLevel;
                const currentMouseY = (e.clientY - panY) / zoomLevel;
                let newWidth = initialNoteWidth + (currentMouseX - initialResizeMouseX);
                let newHeight = initialNoteHeight + (currentMouseY - initialResizeMouseY);
                noteEl.style.width = `${Math.max(newWidth, MIN_NOTE_WIDTH)}px`;
                noteEl.style.height = `${Math.max(newHeight, MIN_NOTE_HEIGHT)}px`;
            }
        }

        function handleGlobalMouseUp() {
            if (isPanning) { isPanning = false; saveState(); }
            if (isDraggingNote && selectedNoteId) {
                const note = notes.find(n => n.id === selectedNoteId);
                const noteEl = canvas.querySelector(`.note[data-id="${selectedNoteId}"]`);
                if (note && noteEl) {
                    note.x = snapToGrid(parseFloat(noteEl.style.left));
                    note.y = snapToGrid(parseFloat(noteEl.style.top));
                    noteEl.style.left = `${note.x}px`; noteEl.style.top = `${note.y}px`;
                    saveState();
                }
                isDraggingNote = false;
            }
            if (isResizingNote && selectedNoteId) {
                const note = notes.find(n => n.id === selectedNoteId);
                const noteEl = canvas.querySelector(`.note[data-id="${selectedNoteId}"]`);
                if (note && noteEl) {
                    note.width = snapToGrid(Math.max(parseFloat(noteEl.style.width), MIN_NOTE_WIDTH));
                    note.height = snapToGrid(Math.max(parseFloat(noteEl.style.height), MIN_NOTE_HEIGHT));
                    noteEl.style.width = `${note.width}px`; noteEl.style.height = `${note.height}px`;
                    saveState();
                }
                isResizingNote = false;
            }
            // Reset cursors
            if (!isPanning && !isDraggingNote && !isResizingNote) {
                canvasContainer.style.cursor = 'grab';
                if (selectedNoteId) {
                    const noteEl = canvas.querySelector(`.note[data-id="${selectedNoteId}"]`);
                    if (noteEl) noteEl.style.cursor = 'move';
                }
            }
        }
        
        function renderNotes() {
            canvas.innerHTML = '';
            notes.forEach(note => canvas.appendChild(createNoteElement(note)));
        }

        function addNote() {
            highestZIndex++;
            const viewCenterX = (canvasContainer.offsetWidth / 2 - panX) / zoomLevel;
            const viewCenterY = (canvasContainer.offsetHeight / 2 - panY) / zoomLevel;
            const initialWidth = snapToGrid(240); // Slightly wider default
            const initialHeight = snapToGrid(180); // Slightly taller default

            const newNote = {
                id: `note_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                title: '', content: '',
                x: snapToGrid(viewCenterX - initialWidth / 2),
                y: snapToGrid(viewCenterY - initialHeight / 2),
                width: initialWidth, height: initialHeight,
                color: document.documentElement.classList.contains('dark') ? DARK_NOTE_COLORS[5] : NOTE_COLORS[5],
                zIndex: highestZIndex
            };
            notes.push(newNote);
            const noteEl = createNoteElement(newNote);
            canvas.appendChild(noteEl);
            selectNote(newNote.id);
            noteEl.querySelector('.note-title').focus(); // Focus title of new note
            saveState();
        }

        function deleteSelectedNote() {
            if (!selectedNoteId) return;
            notes = notes.filter(note => note.id !== selectedNoteId);
            canvas.querySelector(`.note[data-id="${selectedNoteId}"]`)?.remove();
            selectedNoteId = null;
            updateToolbarState(); saveState();
        }

        function selectNote(noteId) {
            if (selectedNoteId === noteId && document.querySelector(`.note[data-id="${noteId}"].selected`)) {
                // Already selected, but ensure z-index is handled if needed
                bringToFront(noteId);
            } else {
                deselectAllNotes();
                selectedNoteId = noteId;
                const noteEl = canvas.querySelector(`.note[data-id="${noteId}"]`);
                if (noteEl) {
                    noteEl.classList.add('selected');
                    bringToFront(noteId); // Bring to front on selection
                }
            }
            updateToolbarState();
            updateFormattingButtonStates();
        }

        function deselectAllNotes() {
            if (selectedNoteId) {
                canvas.querySelector(`.note[data-id="${selectedNoteId}"].selected`)?.classList.remove('selected');
            }
            selectedNoteId = null;
            updateToolbarState();
            updateFormattingButtonStates();
        }

        function handleDocumentClickForDeselectionAndPalette(event) {
            // Deselect note if clicked on canvas background
            if ((event.target === canvasContainer || event.target === canvas) && !isPanning && !isDraggingNote && !isResizingNote) {
                deselectAllNotes();
            }
            // Close color palette
            if (activeColorPalette && !activeColorPalette.contains(event.target) && !event.target.classList.contains('note-color-picker')) {
                activeColorPalette.remove(); activeColorPalette = null;
            }
        }
        
        // --- Color Palette --- (Mostly same as before)
        let activeColorPalette = null;
        function showColorPalette(anchorElement, noteId) {
            activeColorPalette?.remove();
            const palette = document.createElement('div');
            palette.className = 'color-palette';
            const currentColors = document.documentElement.classList.contains('dark') ? DARK_NOTE_COLORS : NOTE_COLORS;
            currentColors.forEach(color => {
                const option = document.createElement('div');
                option.className = 'color-option'; option.style.backgroundColor = color;
                option.addEventListener('click', (e) => {
                    e.stopPropagation(); updateNoteColor(noteId, color); palette.remove(); activeColorPalette = null;
                });
                palette.appendChild(option);
            });
            document.body.appendChild(palette);
            const anchorRect = anchorElement.getBoundingClientRect();
            Object.assign(palette.style, { top: `${anchorRect.bottom + 5}px`, left: `${anchorRect.left}px`});
            activeColorPalette = palette;
        }
        function updateNoteColor(noteId, color) {
            const note = notes.find(n => n.id === noteId);
            const noteEl = canvas.querySelector(`.note[data-id="${noteId}"]`);
            if (note && noteEl) {
                note.color = color; noteEl.style.backgroundColor = color;
                noteEl.querySelector('.note-color-picker').style.backgroundColor = color;
                saveState();
            }
        }

        // --- Toolbar & Formatting Commands ---
        function updateToolbarState() {
            const isNoteSelected = !!selectedNoteId;
            deleteNoteBtn.disabled = !isNoteSelected;
            Object.values(formattingButtons).forEach(btn => btn.disabled = !isNoteSelected);
        }

        function execCmd(command, value = null) {
            const contentEl = getSelectedNoteContentElement();
            if (!contentEl || document.activeElement !== contentEl) {
                contentEl?.focus(); // Focus if not already, then user might need to click again or re-select
            }
            document.execCommand(command, false, value);
            if (contentEl) { // Save after command
                const note = notes.find(n => n.id === selectedNoteId);
                if (note) note.content = contentEl.innerHTML;
                saveStateDebounced();
            }
            updateFormattingButtonStates();
        }

        function execCmdFormatBlock(tagName) { execCmd('formatBlock', `<${tagName}>`); }

        function createLink() {
            const contentEl = getSelectedNoteContentElement();
            if (!contentEl) return;
            if (document.activeElement !== contentEl) contentEl.focus();
            
            const selection = window.getSelection();
            let initialText = "";
            if (selection && selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                if (range.startContainer.parentNode.closest('.note-content') === contentEl || range.endContainer.parentNode.closest('.note-content') === contentEl) {
                     initialText = selection.toString();
                }
            }

            const url = prompt("Enter link URL:", "https://");
            if (url) {
                // If no text was selected, or selection was empty, use URL as text
                if (!initialText.trim()) {
                    // execCommand 'createLink' needs a selection. If none, insert URL text then link it.
                    // This is a bit tricky. A simpler way is to ensure there's always some text.
                    // For now, if no text is selected, it might not work as expected or link the prompt's default.
                    // A robust solution would be to insert the URL as text if selection is empty, then select it and call createLink.
                    // Let's try to make it work if there's no selection:
                    if (!selection || selection.toString().length === 0) {
                        document.execCommand('insertText', false, url);
                        // Now re-select the inserted text. This is tricky.
                        // For simplicity, we'll rely on user selecting text or execCommand's behavior.
                    }
                }
                execCmd('createLink', url);
            }
        }

        function insertChecklistItem() {
            const contentEl = getSelectedNoteContentElement();
            if (!contentEl) return;
            if (document.activeElement !== contentEl) contentEl.focus();

            const id = `chk-${Date.now()}`;
            const html = `<div class="checklist-item"><input type="checkbox" id="${id}"><span contenteditable="true">List item</span></div>`;
            document.execCommand('insertHTML', false, html);
            // Focus the new span
            const newSpan = contentEl.querySelector(`#${id}`)?.nextElementSibling;
            if (newSpan) {
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(newSpan);
                range.collapse(false); // to end
                sel.removeAllRanges();
                sel.addRange(range);
            }
            const note = notes.find(n => n.id === selectedNoteId);
            if (note) note.content = contentEl.innerHTML;
            saveState(); // Save immediately for checklist
        }

        function insertInlineCode() {
            surroundSelection('<code>', '</code>', true);
        }
        function insertCodeBlock() {
            surroundSelection('<pre><code>', '</code></pre>', false);
        }

        function surroundSelection(prefix, suffix, isInline) {
            const contentEl = getSelectedNoteContentElement();
            if (!contentEl) return;
            if (document.activeElement !== contentEl) contentEl.focus();

            const sel = window.getSelection();
            if (sel.rangeCount > 0) {
                const range = sel.getRangeAt(0);
                // Check if selection is within the current note's content area
                if (!contentEl.contains(range.commonAncestorContainer)) {
                    console.warn("Selection is outside the active note content.");
                    return;
                }

                const selectedText = sel.toString();
                let replacementHTML;

                if (isInline) {
                    replacementHTML = `${prefix}${selectedText || "code"}${suffix}`;
                } else { // Block element
                    // For <pre>, ensure it's on a new line or wraps the current block
                    // This simple version just wraps the selection.
                    // A more robust version would handle block-level insertion better.
                    replacementHTML = `${prefix}${selectedText || "\n"}${suffix}`;
                }
                
                document.execCommand('insertHTML', false, replacementHTML);

                const note = notes.find(n => n.id === selectedNoteId);
                if (note) note.content = contentEl.innerHTML;
                saveStateDebounced();
            }
        }


        function updateFormattingButtonStates() {
            if (!selectedNoteId) {
                Object.values(formattingButtons).forEach(btn => { btn.classList.remove('active'); btn.disabled = true; });
                return;
            }
            Object.values(formattingButtons).forEach(btn => btn.disabled = false); // Enable all if note selected

            const contentEl = getSelectedNoteContentElement();
            if (document.activeElement === contentEl) {
                try {
                    formattingButtons.bold.classList.toggle('active', document.queryCommandState('bold'));
                    formattingButtons.italic.classList.toggle('active', document.queryCommandState('italic'));
                    formattingButtons.underline.classList.toggle('active', document.queryCommandState('underline'));
                    formattingButtons.strikethrough.classList.toggle('active', document.queryCommandState('strikeThrough'));
                    formattingButtons.ul.classList.toggle('active', document.queryCommandState('insertUnorderedList'));
                    formattingButtons.ol.classList.toggle('active', document.queryCommandState('insertOrderedList'));
                    // For formatBlock elements, check parent node
                    const blockType = document.queryCommandValue('formatBlock').toLowerCase();
                    formattingButtons.h1.classList.toggle('active', blockType === 'h1');
                    formattingButtons.h2.classList.toggle('active', blockType === 'h2');
                    formattingButtons.h3.classList.toggle('active', blockType === 'h3');
                    formattingButtons.quote.classList.toggle('active', blockType === 'blockquote');
                    // Link, checklist, code are harder to query state for, usually not toggled 'active'
                    formattingButtons.link.classList.remove('active');
                    formattingButtons.checklist.classList.remove('active');
                    formattingButtons.inlineCode.classList.remove('active');
                    formattingButtons.codeBlock.classList.remove('active');

                } catch (e) { console.warn("Could not query command state:", e); }
            } else { // Note selected, but content not focused
                Object.values(formattingButtons).forEach(btn => btn.classList.remove('active'));
            }
        }

        // --- Local Storage ---
        const LS_APP_PREFIX = 'modularNotepad_';
        const LS_NOTES_KEY = LS_APP_PREFIX + 'notes_v4_enhanced';
        const LS_TRANSFORM_KEY = LS_APP_PREFIX + 'transform_v4';
        const LS_HIGHEST_Z_KEY = LS_APP_PREFIX + 'highestZ_v4';
        const LS_THEME_KEY = LS_APP_PREFIX + 'theme_v4';
        const LS_GRID_VISIBLE_KEY = LS_APP_PREFIX + 'gridVisible_v4';

        let saveTimeout;
        function saveStateDebounced() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveState, 500); // Debounce save by 500ms
        }

        function saveState() {
            clearTimeout(saveTimeout); // Clear any pending debounced save
            if (notes.some(note => isNaN(note.x) || isNaN(note.y) || isNaN(note.width) || isNaN(note.height) || isNaN(note.zIndex))) {
                console.error("Attempted to save invalid (NaN) note data. Aborting save."); return;
            }
            localStorage.setItem(LS_NOTES_KEY, JSON.stringify(notes));
            localStorage.setItem(LS_TRANSFORM_KEY, JSON.stringify({ zoomLevel, panX, panY }));
            localStorage.setItem(LS_HIGHEST_Z_KEY, highestZIndex.toString());
        }

        function loadState() {
            const storedNotes = localStorage.getItem(LS_NOTES_KEY);
            if (storedNotes) {
                try {
                    notes = JSON.parse(storedNotes).map(note => ({
                        id: note.id,
                        title: note.title || '', // Add default for title
                        content: note.content || '',
                        x: snapToGrid(parseFloat(note.x) || 0),
                        y: snapToGrid(parseFloat(note.y) || 0),
                        width: snapToGrid(Math.max(parseFloat(note.width) || MIN_NOTE_WIDTH, MIN_NOTE_WIDTH)),
                        height: snapToGrid(Math.max(parseFloat(note.height) || MIN_NOTE_HEIGHT, MIN_NOTE_HEIGHT)),
                        color: note.color,
                        zIndex: parseInt(note.zIndex, 10) || 1
                    }));
                } catch (e) { console.error("Error parsing notes:", e); notes = []; }
            }
            const storedTransform = localStorage.getItem(LS_TRANSFORM_KEY);
            if (storedTransform) {
                try {
                    const t = JSON.parse(storedTransform);
                    zoomLevel = parseFloat(t.zoomLevel) || 1;
                    panX = parseFloat(t.panX) || 0;
                    panY = parseFloat(t.panY) || 0;
                } catch (e) { console.error("Error parsing transform:", e); /* defaults already set */ }
            }
            highestZIndex = parseInt(localStorage.getItem(LS_HIGHEST_Z_KEY), 10) || (notes.length > 0 ? Math.max(...notes.map(n => n.zIndex || 0), 0) + 1 : 1);
        }

        // --- Keyboard Shortcuts ---
        document.addEventListener('keydown', (e) => {
            const activeEl = document.activeElement;
            const isContentFocused = activeEl && activeEl.classList.contains('note-content') && activeEl.isContentEditable;
            const isTitleFocused = activeEl && activeEl.classList.contains('note-title') && activeEl.isContentEditable;

            if (isTitleFocused && e.key === 'Enter') { e.preventDefault(); activeEl.blur(); return; } // Prevent newline in title

            if (isContentFocused) {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key.toLowerCase()) {
                        case 'b': e.preventDefault(); execCmd('bold'); break;
                        case 'i': e.preventDefault(); execCmd('italic'); break;
                        case 'u': e.preventDefault(); execCmd('underline'); break;
                    }
                }
                return; // Allow other keys for text editing
            }
            // Global shortcuts (if not typing in content/title)
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNoteId && !isContentFocused && !isTitleFocused) {
                e.preventDefault(); deleteSelectedNote();
            }
        });
        
        // --- Basic Markdown to HTML (Example, not fully integrated for live editing) ---
        function markdownToHtml(text) {
            let html = text;
            // Headlines (simple # to ######)
            html = html.replace(/^###### (.*$)/gim, '<h6>$1</h6>');
            html = html.replace(/^##### (.*$)/gim, '<h5>$1</h5>');
            html = html.replace(/^#### (.*$)/gim, '<h4>$1</h4>');
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            // Bold
            html = html.replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>');
            html = html.replace(/__(.*?)__/gim, '<strong>$1</strong>');
            // Italic
            html = html.replace(/\*(.*?)\*/gim, '<em>$1</em>');
            html = html.replace(/_(.*?)_/gim, '<em>$1</em>');
            // Strikethrough
            html = html.replace(/~~(.*?)~~/gim, '<del>$1</del>');
            // Blockquote
            html = html.replace(/^\> (.*$)/gim, '<blockquote>$1</blockquote>');
            // Links
            html = html.replace(/\[(.*?)\]\((.*?)\)/gim, '<a href="$2">$1</a>');
            // Checklists (very basic, assumes one per line)
            html = html.replace(/^\[x\] (.*$)/gim, '<div class="checklist-item"><input type="checkbox" checked><span>$1</span></div>');
            html = html.replace(/^\[ \] (.*$)/gim, '<div class="checklist-item"><input type="checkbox"><span>$1</span></div>');
            // Unordered List (simple, doesn't handle nesting well)
            html = html.replace(/^\s*[\*\-\+] (.*)/gm, '<li>$1</li>');
            html = html.replace(/<\/li>\n?<li>/gm, '</li><li>'); // Join adjacent items
            html = html.replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>');
            // Ordered List (simple)
            html = html.replace(/^\s*\d+\. (.*)/gm, '<li>$1</li>');
            // html = html.replace(/<\/li>\n?<li>/gm, '</li><li>'); // Already done
            html = html.replace(/(<li>.*<\/li>)/gs, (match, p1) => { // Check if it's already in <ul>
                if (!match.startsWith('<ul>')) return '<ol>' + p1 + '</ol>';
                return match;
            });
            // Code blocks (``` lang ... ```) - simple version
            html = html.replace(/```(\w*)\n([\s\S]*?)\n```/gim, (match, lang, code) => `<pre><code class="language-${lang || ''}">${code.trim()}</code></pre>`);
            // Inline code (`code`)
            html = html.replace(/`([^`]+)`/gim, '<code>$1</code>');
            // New lines to <br> (careful with this, might interfere with block elements)
            // html = html.replace(/\n/g, '<br>'); // Generally avoid this if using block elements properly
            return html;
        }

        // Start
        init();
    </script>
</body>
</html>
