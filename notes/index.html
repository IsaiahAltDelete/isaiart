<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <title>Enhanced Modular Notepad</title>

    <style>
        :root {
            --bg-color-light: #f8f9fa;
            --text-color-light: #212529;
            --card-bg-light: rgba(255, 255, 255, 0.75);
            --card-border-light: rgba(0, 0, 0, 0.1);
            --toolbar-bg-light: rgba(255, 255, 255, 0.9);
            --toolbar-shadow-light: 0 4px 12px rgba(0, 0, 0, 0.1);
            --grid-color-light: rgba(0, 0, 0, 0.08);
            --icon-color-light: #343A40;
            --accent-color: #FFD700; /* Yellow */
            --accent-text-color: #333;
            --placeholder-color-light: #6c757d;
            --danger-color: #dc3545; /* Red for delete */
            --danger-text-color: #ffffff;
            --info-color: #17a2b8; /* Teal for info/import */
            --info-text-color: #ffffff;


            --bg-color-dark: #1a1c1e;
            --text-color-dark: #e0e0e0;
            --card-bg-dark: rgba(40, 42, 44, 0.75);
            --card-border-dark: rgba(255, 255, 255, 0.1);
            --toolbar-bg-dark: rgba(30, 32, 34, 0.9);
            --toolbar-shadow-dark: 0 4px 12px rgba(0, 0, 0, 0.3);
            --grid-color-dark: rgba(255, 255, 255, 0.08);
            --icon-color-dark: #E0E0E0;
            --placeholder-color-dark: #868e96;
        }

        html { font-family: 'Poppins', sans-serif; }
        body {
            background-color: var(--bg-color-light); color: var(--text-color-light);
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow: hidden; margin: 0; padding: 0;
        }
        html.dark body { background-color: var(--bg-color-dark); color: var(--text-color-dark); }

        #canvas-container {
            width: 100vw; height: 100vh; position: relative; overflow: hidden;
            cursor: grab; transition: background-image 0.3s ease;
        }
        .grid-visible {
            background-image:
                linear-gradient(to right, var(--grid-color-light) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color-light) 1px, transparent 1px);
            background-size: 20px 20px; /* GRID_SIZE */
        }
        html.dark .grid-visible {
             background-image:
                linear-gradient(to right, var(--grid-color-dark) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color-dark) 1px, transparent 1px);
        }
        #canvas { position: absolute; transform-origin: 0 0; width: 1px; height: 1px; }

        .note {
            position: absolute;
            background-color: var(--card-bg-light); border: 1px solid var(--card-border-light);
            border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            padding: 0; display: flex; flex-direction: column;
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            transition: box-shadow 0.2s ease-out, background-color 0.3s ease, border-color 0.3s ease;
            overflow: hidden;
        }
        html.dark .note {
            background-color: var(--card-bg-dark); border: 1px solid var(--card-border-dark);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .note:hover { box-shadow: 0 6px 16px rgba(0,0,0,0.12); }
        html.dark .note:hover { box-shadow: 0 6px 16px rgba(0,0,0,0.3); }
        .note.selected {
            box-shadow: 0 0 0 3px var(--accent-color), 0 6px 16px rgba(0,0,0,0.15);
            border-color: var(--accent-color);
        }
        html.dark .note.selected {
            box-shadow: 0 0 0 3px var(--accent-color), 0 6px 16px rgba(0,0,0,0.35);
        }

        .note-header {
            display: flex; align-items: center; padding: 8px 12px;
            border-bottom: 1px solid rgba(0,0,0,0.05); flex-shrink: 0;
            cursor: move;
        }
        html.dark .note-header { border-bottom: 1px solid rgba(255,255,255,0.05); }
        .note-title {
            flex-grow: 1; font-weight: 600; font-size: 16px;
            outline: none; color: var(--text-color-light);
            cursor: default; padding: 2px 0;
        }
        .note-title[contenteditable="true"] {
            cursor: text; background-color: rgba(0,0,0,0.03); border-radius: 3px;
        }
        html.dark .note-title { color: var(--text-color-dark); }
        html.dark .note-title[contenteditable="true"] { background-color: rgba(255,255,255,0.05); }
        .note-title:empty:before {
            content: attr(placeholder); color: var(--placeholder-color-light); font-weight: 500;
        }
        html.dark .note-title:empty:before { color: var(--placeholder-color-dark); }
        .note-color-picker {
            width: 16px; height: 16px; border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.2); cursor: pointer;
            margin-left: 8px; opacity: 0; transition: opacity 0.2s ease; flex-shrink: 0;
        }
        .note:hover .note-color-picker, .note.selected .note-color-picker { opacity: 1; }
        .note-content-wrapper { flex-grow: 1; padding: 12px; overflow-y: auto; cursor: default; }
        .note-content {
            outline: none; font-size: 14px; line-height: 1.7;
            color: var(--text-color-light); min-height: 40px;
        }
        .note-content > div, .note-content > p { margin-top: 0; }
        html.dark .note-content { color: var(--text-color-dark); }
        .note-content:empty:before {
            content: attr(placeholder); color: var(--placeholder-color-light);
            pointer-events: none; display: block;
        }
        html.dark .note-content:empty:before { color: var(--placeholder-color-dark); }

        .checklist-item { display: flex; align-items: flex-start; margin-bottom: 6px; }
        .checklist-item input[type="checkbox"] {
            margin-right: 8px; margin-top: 5px; flex-shrink: 0;
            width: 16px; height: 16px; accent-color: var(--accent-color);
        }
        .checklist-item span { flex-grow: 1; outline: none; min-height: 1.2em; }
        .checklist-item input[type="checkbox"]:checked + span { text-decoration: line-through; color: gray; }

        .note-content h1, .note-content h2, .note-content h3 { margin-top: 0.5em; margin-bottom: 0.25em; font-weight: 600; }
        .note-content h1 { font-size: 1.5em; } .note-content h2 { font-size: 1.3em; } .note-content h3 { font-size: 1.15em; }
        .note-content a { color: var(--accent-color); text-decoration: underline; }
        html.dark .note-content a { color: var(--accent-color); }
        .note-content ul, .note-content ol { margin-left: 20px; padding-left: 5px; margin-top: 0.5em; margin-bottom: 0.5em; }
        .note-content blockquote {
            border-left: 3px solid var(--accent-color); margin-left: 0;
            padding-left: 1em; color: gray; font-style: italic; margin-top: 0.5em; margin-bottom: 0.5em;
        }
        .note-content pre {
            background-color: rgba(0,0,0,0.05); padding: 10px; border-radius: 6px;
            overflow-x: auto; font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em; margin: 0.5em 0; white-space: pre-wrap;
        }
        html.dark .note-content pre { background-color: rgba(255,255,255,0.05); }
        .note-content code {
            background-color: rgba(0,0,0,0.05); padding: 2px 4px; border-radius: 4px;
            font-family: 'Courier New', Courier, monospace; font-size: 0.9em;
        }
        html.dark .note-content code { background-color: rgba(255,255,255,0.05); }
        .note-content pre code { background-color: transparent; padding: 0; border-radius: 0; white-space: pre; }

        .note-resize-handle {
            position: absolute; bottom: 1px; right: 1px; width: 20px; height: 20px;
            cursor: nwse-resize; display: flex; align-items: center; justify-content: center;
            opacity: 0; transition: opacity 0.2s ease; z-index: 10;
        }
        .note.selected .note-resize-handle { opacity: 0.7; }
        .note.selected .note-resize-handle:hover { opacity: 1; }
        .note-resize-handle .material-symbols-outlined { font-size: 18px; color: var(--icon-color-light); }
        html.dark .note-resize-handle .material-symbols-outlined { color: var(--icon-color-dark); }

        #toolbar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: var(--toolbar-bg-light); padding: 8px 10px;
            border-radius: 16px; box-shadow: var(--toolbar-shadow-light);
            display: flex; flex-wrap: wrap; gap: 5px;
            align-items: center; z-index: 1000;
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            max-width: 95vw; /* Slightly more room for new buttons */
            justify-content: center;
        }
        html.dark #toolbar { background-color: var(--toolbar-bg-dark); box-shadow: var(--toolbar-shadow-dark); }
        .toolbar-button {
            background-color: transparent; border: none; padding: 7px;
            border-radius: 8px; cursor: pointer; display: flex;
            align-items: center; justify-content: center;
            color: var(--icon-color-light);
            transition: background-color 0.2s ease, color 0.2s ease;
            position: relative;
        }
        html.dark .toolbar-button { color: var(--icon-color-dark); }
        .toolbar-button:hover { background-color: rgba(0,0,0,0.05); }
        html.dark .toolbar-button:hover { background-color: rgba(255,255,255,0.1); }
        .toolbar-button.active { background-color: var(--accent-color); color: var(--accent-text-color); }
        .toolbar-button:disabled { opacity: 0.5; cursor: not-allowed; }
        .toolbar-button:disabled:hover { background-color: transparent; }
        .toolbar-separator { width: 1px; height: 24px; background-color: rgba(0,0,0,0.1); margin: 0 4px; }
        html.dark .toolbar-separator { background-color: rgba(255,255,255,0.1); }

        .material-symbols-outlined { font-size: 20px; }

        .color-palette {
            position: fixed; background-color: var(--toolbar-bg-light);
            border: 1px solid var(--card-border-light); border-radius: 8px;
            padding: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex; gap: 6px; z-index: 1001;
        }
        html.dark .color-palette {
            background-color: var(--toolbar-bg-dark); border: 1px solid var(--card-border-dark);
        }
        .color-option {
            width: 20px; height: 20px; border-radius: 50%; cursor: pointer;
            border: 1px solid rgba(0,0,0,0.1);
        }
        html.dark .color-option { border: 1px solid rgba(255,255,255,0.1); }

        .note-content::-webkit-scrollbar { width: 8px; }
        .note-content::-webkit-scrollbar-track { background: transparent; }
        .note-content::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 4px; }
        html.dark .note-content::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.2); }
        .note-content::-webkit-scrollbar-thumb:hover { background-color: rgba(0,0,0,0.3); }
        html.dark .note-content::-webkit-scrollbar-thumb:hover { background-color: rgba(255,255,255,0.3); }

        #customTooltip {
            position: absolute; background-color: var(--text-color-light);
            color: var(--bg-color-light); padding: 4px 8px; border-radius: 4px; font-size: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 1050;
            pointer-events: none; white-space: nowrap;
            transition: opacity 0.1s ease-in-out, transform 0.1s ease-in-out;
            opacity: 0; transform: translateY(5px);
        }
        #customTooltip.visible { opacity: 1; transform: translateY(0); }
        html.dark #customTooltip { background-color: var(--text-color-dark); color: var(--bg-color-dark); }

        /* Generic Modal Styles */
        .modal-overlay { position: fixed; inset: 0; background-color: rgba(0,0,0,0.5); dark:bg-opacity-70; z-index: 1040; }
        .modal-content {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: var(--card-bg-light); color: var(--text-color-light);
            padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            width: 100%; max-width: 24rem; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--card-border-light); z-index: 1045;
        }
        html.dark .modal-content {
            background-color: var(--card-bg-dark); color: var(--text-color-dark);
            border: 1px solid var(--card-border-dark);
        }
        .modal-content h3 { font-size: 1.25rem; font-weight: 600; margin-bottom: 0.5rem; }
        .modal-content p { font-size: 0.875rem; color: #6b7280; margin-bottom: 1.5rem; }
        html.dark .modal-content p { color: #9ca3af; }
        .modal-content .buttons { display: flex; justify-content: flex-end; gap: 0.75rem; }
        .modal-content button {
            padding: 0.5rem 1rem; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500;
            border: none; cursor: pointer; transition: background-color 0.2s ease;
        }
        .modal-content button.confirm-danger { background-color: var(--danger-color); color: var(--danger-text-color); }
        .modal-content button.confirm-danger:hover { background-color: #c82333; }
        .modal-content button.confirm-info { background-color: var(--info-color); color: var(--info-text-color); }
        .modal-content button.confirm-info:hover { background-color: #138496; } /* Darker teal */
        .modal-content button.cancel {
            background-color: var(--bg-color-light); color: var(--text-color-light);
            border: 1px solid var(--card-border-light);
        }
        html.dark .modal-content button.cancel {
            background-color: var(--toolbar-bg-dark); color: var(--text-color-dark);
            border: 1px solid var(--card-border-dark);
        }
        .modal-content button.cancel:hover { background-color: rgba(0,0,0,0.05); }
        html.dark .modal-content button.cancel:hover { background-color: rgba(255,255,255,0.1); }
    </style>
</head>
<body>

    <div id="canvas-container"><div id="canvas"></div></div>
    <div id="toolbar">
        <button id="addNoteBtn" class="toolbar-button" data-tooltip="Add Note"><span class="material-symbols-outlined">add_circle</span></button>
        <button id="deleteNoteBtn" class="toolbar-button" data-tooltip="Delete Selected Note" disabled><span class="material-symbols-outlined">delete</span></button>
        <div class="toolbar-separator"></div>
        <button id="zoomInBtn" class="toolbar-button" data-tooltip="Zoom In"><span class="material-symbols-outlined">zoom_in</span></button>
        <button id="zoomOutBtn" class="toolbar-button" data-tooltip="Zoom Out"><span class="material-symbols-outlined">zoom_out</span></button>
        <button id="resetZoomBtn" class="toolbar-button" data-tooltip="Reset View"><span class="material-symbols-outlined">center_focus_strong</span></button>
        <div class="toolbar-separator"></div>
        <button id="boldBtn" class="toolbar-button" data-tooltip="Bold (Ctrl+B)"><span class="material-symbols-outlined">format_bold</span></button>
        <button id="italicBtn" class="toolbar-button" data-tooltip="Italic (Ctrl+I)"><span class="material-symbols-outlined">format_italic</span></button>
        <button id="underlineBtn" class="toolbar-button" data-tooltip="Underline (Ctrl+U)"><span class="material-symbols-outlined">format_underlined</span></button>
        <button id="strikethroughBtn" class="toolbar-button" data-tooltip="Strikethrough"><span class="material-symbols-outlined">format_strikethrough</span></button>
        <button id="linkBtn" class="toolbar-button" data-tooltip="Create Link"><span class="material-symbols-outlined">link</span></button>
        <div class="toolbar-separator"></div>
        <button id="h1Btn" class="toolbar-button" data-tooltip="Heading 1"><span class="material-symbols-outlined">format_h1</span></button>
        <button id="h2Btn" class="toolbar-button" data-tooltip="Heading 2"><span class="material-symbols-outlined">format_h2</span></button>
        <button id="h3Btn" class="toolbar-button" data-tooltip="Heading 3"><span class="material-symbols-outlined">format_h3</span></button>
        <button id="ulBtn" class="toolbar-button" data-tooltip="Unordered List"><span class="material-symbols-outlined">format_list_bulleted</span></button>
        <button id="olBtn" class="toolbar-button" data-tooltip="Ordered List"><span class="material-symbols-outlined">format_list_numbered</span></button>
        <button id="checklistBtn" class="toolbar-button" data-tooltip="Checklist Item"><span class="material-symbols-outlined">checklist</span></button>
        <button id="quoteBtn" class="toolbar-button" data-tooltip="Blockquote"><span class="material-symbols-outlined">format_quote</span></button>
        <button id="inlineCodeBtn" class="toolbar-button" data-tooltip="Inline Code"><span class="material-symbols-outlined">code</span></button>
        <button id="codeBlockBtn" class="toolbar-button" data-tooltip="Code Block"><span class="material-symbols-outlined">code_blocks</span></button>
        <div class="toolbar-separator"></div>
        <button id="toggleGridBtn" class="toolbar-button" data-tooltip="Toggle Grid"><span class="material-symbols-outlined">grid_on</span></button>
        <button id="toggleThemeBtn" class="toolbar-button" data-tooltip="Toggle Theme"><span class="material-symbols-outlined">brightness_6</span></button>
        <div class="toolbar-separator"></div>
        <button id="exportCanvasBtn" class="toolbar-button" data-tooltip="Export Canvas"><span class="material-symbols-outlined">download</span></button>
        <button id="importCanvasBtn" class="toolbar-button" data-tooltip="Import Canvas"><span class="material-symbols-outlined">upload_file</span></button>
    </div>
    <input type="file" id="importFilePicker" accept=".json" class="hidden">

    <div id="customTooltip" class="hidden"></div>

    <div id="confirmDeleteOverlay" class="modal-overlay hidden"></div>
    <div id="confirmDeleteModal" class="modal-content hidden">
        <h3>Delete Note?</h3>
        <p>Are you sure you want to permanently delete this note? This action cannot be undone.</p>
        <div class="buttons">
            <button id="cancelDeleteBtn" class="cancel">Cancel</button>
            <button id="confirmDeleteFinalBtn" class="confirm-danger">Delete</button>
        </div>
    </div>

    <div id="confirmImportOverlay" class="modal-overlay hidden"></div>
    <div id="confirmImportModal" class="modal-content hidden">
        <h3>Import Canvas?</h3>
        <p>Importing a canvas will overwrite your current notes and settings. Are you sure you want to proceed?</p>
        <div class="buttons">
            <button id="cancelImportBtn" class="cancel">Cancel</button>
            <button id="confirmImportFinalBtn" class="confirm-info">Import</button>
        </div>
    </div>


    <script>
        // DOM Elements
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('canvas');
        const toolbar = document.getElementById('toolbar');
        const customTooltipEl = document.getElementById('customTooltip');
        const confirmDeleteOverlay = document.getElementById('confirmDeleteOverlay');
        const confirmDeleteModal = document.getElementById('confirmDeleteModal');
        const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
        const confirmDeleteFinalBtn = document.getElementById('confirmDeleteFinalBtn');
        const confirmImportOverlay = document.getElementById('confirmImportOverlay');
        const confirmImportModal = document.getElementById('confirmImportModal');
        const cancelImportBtn = document.getElementById('cancelImportBtn');
        const confirmImportFinalBtn = document.getElementById('confirmImportFinalBtn');
        const importFilePicker = document.getElementById('importFilePicker');


        const addNoteBtn = document.getElementById('addNoteBtn');
        const deleteNoteBtn = document.getElementById('deleteNoteBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        const toggleGridBtn = document.getElementById('toggleGridBtn');
        const toggleThemeBtn = document.getElementById('toggleThemeBtn');
        const exportCanvasBtn = document.getElementById('exportCanvasBtn');
        const importCanvasBtn = document.getElementById('importCanvasBtn');
        const formattingButtons = {};
        Object.assign(formattingButtons, {
            bold: document.getElementById('boldBtn'), italic: document.getElementById('italicBtn'),
            underline: document.getElementById('underlineBtn'), strikethrough: document.getElementById('strikethroughBtn'),
            link: document.getElementById('linkBtn'), h1: document.getElementById('h1Btn'),
            h2: document.getElementById('h2Btn'), h3: document.getElementById('h3Btn'),
            ul: document.getElementById('ulBtn'), ol: document.getElementById('olBtn'),
            checklist: document.getElementById('checklistBtn'), quote: document.getElementById('quoteBtn'),
            inlineCode: document.getElementById('inlineCodeBtn'), codeBlock: document.getElementById('codeBlockBtn'),
        });

        // State
        let notes = [];
        let selectedNoteId = null;
        let noteIdToDelete = null;
        let fileToImport = null; // For import confirmation
        let highestZIndex = 1;
        let zoomLevel = 1;
        let panX = 0, panY = 0;
        let isPanning = false, lastPanX, lastPanY;
        let isDraggingNote = false, isResizingNote = false;
        let dragOffsetX, dragOffsetY;
        let initialResizeMouseX, initialResizeMouseY, initialNoteWidth, initialNoteHeight;

        // Constants
        const GRID_SIZE = 20;
        const MIN_NOTE_WIDTH = GRID_SIZE * 5;
        const MIN_NOTE_HEIGHT = GRID_SIZE * 4;
        const NOTE_COLORS = ['rgba(255, 215, 0, 0.7)', 'rgba(173, 216, 230, 0.7)', 'rgba(144, 238, 144, 0.7)', 'rgba(255, 182, 193, 0.7)', 'rgba(221, 160, 221, 0.7)', 'rgba(240, 240, 240, 0.7)'];
        const DARK_NOTE_COLORS = ['rgba(255, 215, 0, 0.6)', 'rgba(70, 130, 180, 0.6)', 'rgba(60, 179, 113, 0.6)', 'rgba(219, 112, 147, 0.6)', 'rgba(147, 112, 219, 0.6)', 'rgba(60, 60, 60, 0.7)'];
        const EXPORT_VERSION = "1.0.0"; // For data structure versioning

        function snapToGrid(value, gridSize = GRID_SIZE) { return Math.round(value / gridSize) * gridSize; }
        function getSelectedNoteContentElement() {
            if (!selectedNoteId) return null;
            const noteEl = canvas.querySelector(`.note[data-id="${selectedNoteId}"]`);
            return noteEl ? noteEl.querySelector('.note-content') : null;
        }

        function init() {
            loadState(); updateCanvasTransform(); renderNotes(); updateToolbarState();
            applyTheme(localStorage.getItem('modularNotepad_theme_v8') || 'light');
            applyGridVisibility(localStorage.getItem('modularNotepad_gridVisible_v8') === 'true');

            canvasContainer.addEventListener('mousedown', handleCanvasMouseDown);
            canvasContainer.addEventListener('wheel', handleCanvasWheel, { passive: false });
            document.addEventListener('mousemove', handleGlobalMouseMove);
            document.addEventListener('mouseup', handleGlobalMouseUp);

            setupToolbarButtonListeners();
            setupCustomTooltips();
            setupDeleteConfirmation();
            setupImportConfirmation();

            document.addEventListener('selectionchange', updateFormattingButtonStates);
            document.addEventListener('click', handleDocumentClickForDeselectionAndPalette);
        }

        function setupToolbarButtonListeners() {
            addNoteBtn.addEventListener('click', addNote);
            deleteNoteBtn.addEventListener('click', triggerDeleteConfirmation);
            zoomInBtn.addEventListener('click', () => zoomViaButton(1.2));
            zoomOutBtn.addEventListener('click', () => zoomViaButton(1 / 1.2));
            resetZoomBtn.addEventListener('click', resetView);
            toggleGridBtn.addEventListener('click', toggleGrid);
            toggleThemeBtn.addEventListener('click', toggleTheme);
            exportCanvasBtn.addEventListener('click', exportCanvasData);
            importCanvasBtn.addEventListener('click', () => importFilePicker.click());
            importFilePicker.addEventListener('change', handleFileImportSelection);

            Object.entries(formattingButtons).forEach(([key, btn]) => {
                switch (key) {
                    case 'bold': btn.addEventListener('click', () => execCmd('bold')); break;
                    case 'italic': btn.addEventListener('click', () => execCmd('italic')); break;
                    case 'underline': btn.addEventListener('click', () => execCmd('underline')); break;
                    case 'strikethrough': btn.addEventListener('click', () => execCmd('strikeThrough')); break;
                    case 'link': btn.addEventListener('click', createLink); break;
                    case 'h1': btn.addEventListener('click', () => execCmdFormatBlock('h1')); break;
                    case 'h2': btn.addEventListener('click', () => execCmdFormatBlock('h2')); break;
                    case 'h3': btn.addEventListener('click', () => execCmdFormatBlock('h3')); break;
                    case 'ul': btn.addEventListener('click', () => execCmd('insertUnorderedList')); break;
                    case 'ol': btn.addEventListener('click', () => execCmd('insertOrderedList')); break;
                    case 'checklist': btn.addEventListener('click', insertChecklistItemFromToolbar); break;
                    case 'quote': btn.addEventListener('click', () => execCmdFormatBlock('blockquote')); break;
                    case 'inlineCode': btn.addEventListener('click', insertInlineCode); break;
                    case 'codeBlock': btn.addEventListener('click', insertCodeBlock); break;
                }
            });
        }

        function setupCustomTooltips() {
            const buttonsWithTooltips = toolbar.querySelectorAll('button[data-tooltip]');
            buttonsWithTooltips.forEach(button => {
                const tooltipText = button.dataset.tooltip;
                button.addEventListener('mouseenter', (e) => {
                    if (tooltipText) {
                        customTooltipEl.textContent = tooltipText;
                        const btnRect = button.getBoundingClientRect();
                        customTooltipEl.style.left = `${btnRect.left + btnRect.width / 2 - customTooltipEl.offsetWidth / 2}px`;
                        customTooltipEl.style.top = `${btnRect.top - customTooltipEl.offsetHeight - 6}px`;
                        customTooltipEl.classList.remove('hidden'); customTooltipEl.classList.add('visible');
                    }
                });
                button.addEventListener('mouseleave', () => {
                    customTooltipEl.classList.remove('visible');
                    setTimeout(() => { if (!customTooltipEl.classList.contains('visible')) customTooltipEl.classList.add('hidden'); }, 150);
                });
            });
        }

        function setupDeleteConfirmation() {
            cancelDeleteBtn.addEventListener('click', hideConfirmDeletePopup);
            confirmDeleteFinalBtn.addEventListener('click', () => {
                if (noteIdToDelete) performActualDeletion(noteIdToDelete);
                hideConfirmDeletePopup();
            });
            confirmDeleteOverlay.addEventListener('click', hideConfirmDeletePopup);
        }
        function triggerDeleteConfirmation() {
            if (selectedNoteId) {
                noteIdToDelete = selectedNoteId;
                confirmDeleteOverlay.classList.remove('hidden'); confirmDeleteModal.classList.remove('hidden');
                confirmDeleteFinalBtn.focus();
            }
        }
        function hideConfirmDeletePopup() {
            confirmDeleteOverlay.classList.add('hidden'); confirmDeleteModal.classList.add('hidden');
            noteIdToDelete = null;
        }
        function performActualDeletion(idOfNoteToDelete) {
            notes = notes.filter(note => note.id !== idOfNoteToDelete);
            canvas.querySelector(`.note[data-id="${idOfNoteToDelete}"]`)?.remove();
            if (selectedNoteId === idOfNoteToDelete) selectedNoteId = null;
            updateToolbarState(); saveState();
        }

        function setupImportConfirmation() {
            cancelImportBtn.addEventListener('click', hideConfirmImportPopup);
            confirmImportFinalBtn.addEventListener('click', () => {
                if (fileToImport) performActualImport(fileToImport);
                hideConfirmImportPopup();
            });
            confirmImportOverlay.addEventListener('click', hideConfirmImportPopup);
        }
        function triggerConfirmImportPopup(file) {
            fileToImport = file;
            confirmImportOverlay.classList.remove('hidden');
            confirmImportModal.classList.remove('hidden');
            confirmImportFinalBtn.focus();
        }
        function hideConfirmImportPopup() {
            confirmImportOverlay.classList.add('hidden');
            confirmImportModal.classList.add('hidden');
            fileToImport = null;
            importFilePicker.value = ''; // Reset file picker
        }
        
        function applyTheme(theme) {
            document.documentElement.classList.toggle('dark', theme === 'dark');
            toggleThemeBtn.querySelector('.material-symbols-outlined').textContent = theme === 'dark' ? 'light_mode' : 'dark_mode';
            localStorage.setItem('modularNotepad_theme_v8', theme);
        }
        function toggleTheme() { applyTheme(document.documentElement.classList.contains('dark') ? 'light' : 'dark'); }
        function applyGridVisibility(visible) {
            canvasContainer.classList.toggle('grid-visible', visible);
            toggleGridBtn.classList.toggle('active', visible);
            localStorage.setItem('modularNotepad_gridVisible_v8', visible);
        }
        function toggleGrid() { applyGridVisibility(!canvasContainer.classList.contains('grid-visible')); }

        function updateCanvasTransform() { canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`; }
        function zoomAtPoint(mouseX, mouseY, factor) {
            const mouseBeforeZoomX = (mouseX - panX) / zoomLevel;
            const mouseBeforeZoomY = (mouseY - panY) / zoomLevel;
            zoomLevel = Math.max(0.1, Math.min(zoomLevel * factor, 5));
            panX = mouseX - mouseBeforeZoomX * zoomLevel;
            panY = mouseY - mouseBeforeZoomY * zoomLevel;
            updateCanvasTransform(); saveState();
        }
        function zoomViaButton(factor) {
            const rect = canvasContainer.getBoundingClientRect();
            zoomAtPoint(rect.width / 2, rect.height / 2, factor);
        }
        function resetView() { zoomLevel = 1; panX = 0; panY = 0; updateCanvasTransform(); saveState(); }
        function handleCanvasMouseDown(e) {
            if (e.target === canvasContainer || e.target === canvas) {
                isPanning = true; canvasContainer.style.cursor = 'grabbing';
                lastPanX = e.clientX; lastPanY = e.clientY;
            }
        }
        function handleCanvasWheel(e) {
            e.preventDefault();
            const deltaFactor = e.deltaY > 0 ? 1 / 1.1 : 1.1;
            const rect = canvasContainer.getBoundingClientRect();
            zoomAtPoint(e.clientX - rect.left, e.clientY - rect.top, deltaFactor);
        }

        function createNoteElement(note) {
            const noteEl = document.createElement('div');
            noteEl.className = 'note'; noteEl.dataset.id = note.id;
            Object.assign(noteEl.style, {
                left: `${note.x}px`, top: `${note.y}px`, width: `${note.width}px`,
                height: `${note.height}px`, zIndex: note.zIndex, backgroundColor: note.color
            });
            if (note.id === selectedNoteId) noteEl.classList.add('selected');

            const headerEl = document.createElement('div'); headerEl.className = 'note-header';
            const titleEl = document.createElement('div'); titleEl.className = 'note-title';
            titleEl.setAttribute('contenteditable', 'false'); titleEl.setAttribute('placeholder', 'Title');
            titleEl.innerHTML = note.title || '';
            titleEl.addEventListener('dblclick', () => {
                titleEl.setAttribute('contenteditable', 'true'); titleEl.focus(); document.execCommand('selectAll', false, null);
            });
            titleEl.addEventListener('blur', () => {
                titleEl.setAttribute('contenteditable', 'false'); note.title = titleEl.innerHTML; saveState();
            });
            titleEl.addEventListener('input', () => {
                if (titleEl.getAttribute('contenteditable') === 'true') { note.title = titleEl.innerHTML; saveStateDebounced(); }
            });
            titleEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && titleEl.getAttribute('contenteditable') === 'true') { e.preventDefault(); titleEl.blur(); }
            });

            const colorPickerInput = document.createElement('input'); colorPickerInput.type = 'button';
            colorPickerInput.className = 'note-color-picker'; colorPickerInput.title = "Change note color";
            colorPickerInput.style.backgroundColor = note.color || (document.documentElement.classList.contains('dark') ? DARK_NOTE_COLORS[5] : NOTE_COLORS[5]);
            colorPickerInput.addEventListener('click', (e) => { e.stopPropagation(); showColorPalette(e.target, note.id); });
            
            headerEl.appendChild(titleEl); headerEl.appendChild(colorPickerInput);

            const contentWrapperEl = document.createElement('div'); contentWrapperEl.className = 'note-content-wrapper';
            const contentEl = document.createElement('div'); contentEl.className = 'note-content';
            contentEl.setAttribute('contenteditable', 'true'); contentEl.setAttribute('placeholder', 'Start typing...');
            contentEl.innerHTML = note.content;
            contentEl.addEventListener('focus', () => { selectNote(note.id); updateFormattingButtonStates(); });
            contentEl.addEventListener('blur', () => { note.content = contentEl.innerHTML; saveState(); });
            contentEl.addEventListener('input', () => { note.content = contentEl.innerHTML; saveStateDebounced(); });
            contentEl.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox' && e.target.closest('.checklist-item')) { note.content = contentEl.innerHTML; saveState(); }
            });
            contentEl.addEventListener('keydown', handleNoteContentKeydown);
            contentWrapperEl.appendChild(contentEl);

            const resizeHandleEl = document.createElement('div'); resizeHandleEl.className = 'note-resize-handle';
            resizeHandleEl.innerHTML = `<span class="material-symbols-outlined">aspect_ratio</span>`;
            noteEl.append(headerEl, contentWrapperEl, resizeHandleEl);

            headerEl.addEventListener('mousedown', (e) => {
                const titleIsEditable = titleEl.getAttribute('contenteditable') === 'true';
                if (e.target.closest('.note-color-picker') || (e.target.closest('.note-title') && titleIsEditable)) {
                    if (e.target.closest('.note-title') && !titleIsEditable && !noteEl.classList.contains('selected')) selectNote(note.id);
                    return; 
                }
                e.stopPropagation(); isDraggingNote = true; selectNote(note.id);
                canvasContainer.style.cursor = 'grabbing';
                const noteRect = noteEl.getBoundingClientRect();
                dragOffsetX = (e.clientX - noteRect.left) / zoomLevel; dragOffsetY = (e.clientY - noteRect.top) / zoomLevel;
                bringToFront(note.id);
            });
            resizeHandleEl.addEventListener('mousedown', (e) => {
                e.stopPropagation(); isResizingNote = true; selectNote(note.id);
                noteEl.style.cursor = 'nwse-resize'; canvasContainer.style.cursor = 'nwse-resize';
                initialResizeMouseX = (e.clientX - panX) / zoomLevel; initialResizeMouseY = (e.clientY - panY) / zoomLevel;
                initialNoteWidth = parseFloat(noteEl.style.width); initialNoteHeight = parseFloat(noteEl.style.height);
                bringToFront(note.id);
            });
            return noteEl;
        }

        function handleNoteContentKeydown(e) {
            const contentEl = e.target; const selection = window.getSelection();
            const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
            if (e.key === 'Enter' && range) {
                const parentNode = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE ? range.commonAncestorContainer : range.commonAncestorContainer.parentElement;
                const parentChecklistItem = parentNode.closest('.checklist-item');
                if (parentChecklistItem) {
                    e.preventDefault();
                    if (e.shiftKey) { document.execCommand('insertLineBreak'); }
                    else {
                        const newChecklistItemId = `chk-${Date.now()}`;
                        const newChecklistItemHtml = `<div class="checklist-item"><input type="checkbox" id="${newChecklistItemId}"><span contenteditable="true"> </span></div>`;
                        parentChecklistItem.insertAdjacentHTML('afterend', newChecklistItemHtml);
                        const newSpan = parentChecklistItem.nextElementSibling.querySelector('span[contenteditable="true"]');
                        if (newSpan) {
                            const newRange = document.createRange(); newRange.selectNodeContents(newSpan);
                            newRange.collapse(true); selection.removeAllRanges(); selection.addRange(newRange); newSpan.focus();
                        }
                    }
                    const currentNote = notes.find(n => n.id === selectedNoteId);
                    if (currentNote) { currentNote.content = contentEl.innerHTML; saveState(); }
                    return;
                }
            }
        }

        function bringToFront(noteId) {
            const note = notes.find(n => n.id === noteId);
            const noteEl = canvas.querySelector(`.note[data-id="${noteId}"]`);
            if (note && noteEl && (note.zIndex < highestZIndex || notes.filter(n => n.zIndex === note.zIndex).length > 1 && note.zIndex !== highestZIndex)) {
                highestZIndex++; note.zIndex = highestZIndex; noteEl.style.zIndex = note.zIndex;
            }
        }
        
        function handleGlobalMouseMove(e) {
            if (isPanning) {
                const dx = e.clientX - lastPanX; const dy = e.clientY - lastPanY;
                panX += dx; panY += dy; lastPanX = e.clientX; lastPanY = e.clientY;
                updateCanvasTransform();
            } else if (isDraggingNote && selectedNoteId) {
                const noteEl = canvas.querySelector(`.note[data-id="${selectedNoteId}"]`); if (!noteEl) return;
                let newX = (e.clientX - panX) / zoomLevel - dragOffsetX;
                let newY = (e.clientY - panY) / zoomLevel - dragOffsetY;
                noteEl.style.left = `${newX}px`; noteEl.style.top = `${newY}px`;
            } else if (isResizingNote && selectedNoteId) {
                const noteEl = canvas.querySelector(`.note[data-id="${selectedNoteId}"]`); if (!noteEl) return;
                const currentMouseX = (e.clientX - panX) / zoomLevel; const currentMouseY = (e.clientY - panY) / zoomLevel;
                let newWidth = initialNoteWidth + (currentMouseX - initialResizeMouseX);
                let newHeight = initialNoteHeight + (currentMouseY - initialResizeMouseY);
                noteEl.style.width = `${Math.max(newWidth, MIN_NOTE_WIDTH)}px`;
                noteEl.style.height = `${Math.max(newHeight, MIN_NOTE_HEIGHT)}px`;
            }
        }
        function handleGlobalMouseUp() {
            if (isPanning) { isPanning = false; saveState(); }
            if (isDraggingNote && selectedNoteId) {
                const note = notes.find(n => n.id === selectedNoteId);
                const noteEl = canvas.querySelector(`.note[data-id="${selectedNoteId}"]`);
                if (note && noteEl) {
                    note.x = snapToGrid(parseFloat(noteEl.style.left)); note.y = snapToGrid(parseFloat(noteEl.style.top));
                    noteEl.style.left = `${note.x}px`; noteEl.style.top = `${note.y}px`; saveState();
                }
                isDraggingNote = false;
            }
            if (isResizingNote && selectedNoteId) {
                const note = notes.find(n => n.id === selectedNoteId);
                const noteEl = canvas.querySelector(`.note[data-id="${selectedNoteId}"]`);
                if (note && noteEl) {
                    note.width = snapToGrid(Math.max(parseFloat(noteEl.style.width), MIN_NOTE_WIDTH));
                    note.height = snapToGrid(Math.max(parseFloat(noteEl.style.height), MIN_NOTE_HEIGHT));
                    noteEl.style.width = `${note.width}px`; noteEl.style.height = `${note.height}px`; saveState();
                }
                isResizingNote = false;
            }
            if (!isPanning && !isDraggingNote && !isResizingNote) canvasContainer.style.cursor = 'grab';
        }
        
        function renderNotes() { canvas.innerHTML = ''; notes.forEach(note => canvas.appendChild(createNoteElement(note))); }
        function addNote() {
            highestZIndex++;
            const viewCenterX = (canvasContainer.offsetWidth / 2 - panX) / zoomLevel;
            const viewCenterY = (canvasContainer.offsetHeight / 2 - panY) / zoomLevel;
            const initialWidth = snapToGrid(240); const initialHeight = snapToGrid(180);
            const newNote = {
                id: `note_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, title: '', content: '',
                x: snapToGrid(viewCenterX - initialWidth / 2), y: snapToGrid(viewCenterY - initialHeight / 2),
                width: initialWidth, height: initialHeight,
                color: document.documentElement.classList.contains('dark') ? DARK_NOTE_COLORS[5] : NOTE_COLORS[5],
                zIndex: highestZIndex
            };
            notes.push(newNote);
            const noteEl = createNoteElement(newNote); canvas.appendChild(noteEl);
            selectNote(newNote.id); saveState();
        }
        function selectNote(noteId) {
            if (selectedNoteId === noteId && document.querySelector(`.note[data-id="${noteId}"].selected`)) {
                bringToFront(noteId);
            } else {
                deselectAllNotes(); selectedNoteId = noteId;
                const noteEl = canvas.querySelector(`.note[data-id="${noteId}"]`);
                if (noteEl) { noteEl.classList.add('selected'); bringToFront(noteId); }
            }
            updateToolbarState(); updateFormattingButtonStates();
        }
        function deselectAllNotes() {
            if (selectedNoteId) {
                const prevSelectedNoteEl = canvas.querySelector(`.note[data-id="${selectedNoteId}"].selected`);
                if (prevSelectedNoteEl) {
                    prevSelectedNoteEl.classList.remove('selected');
                    const titleEl = prevSelectedNoteEl.querySelector('.note-title[contenteditable="true"]');
                    titleEl?.blur();
                }
            }
            selectedNoteId = null; updateToolbarState(); updateFormattingButtonStates();
        }
        function handleDocumentClickForDeselectionAndPalette(event) {
            if ((event.target === canvasContainer || event.target === canvas) && !isPanning && !isDraggingNote && !isResizingNote) {
                deselectAllNotes();
            }
            if (activeColorPalette && !activeColorPalette.contains(event.target) && !event.target.classList.contains('note-color-picker')) {
                activeColorPalette.remove(); activeColorPalette = null;
            }
        }
        
        let activeColorPalette = null;
        function showColorPalette(anchorElement, noteId) {
            activeColorPalette?.remove();
            const palette = document.createElement('div'); palette.className = 'color-palette';
            const currentColors = document.documentElement.classList.contains('dark') ? DARK_NOTE_COLORS : NOTE_COLORS;
            currentColors.forEach(color => {
                const option = document.createElement('div'); option.className = 'color-option'; option.style.backgroundColor = color;
                option.addEventListener('click', (e) => {
                    e.stopPropagation(); updateNoteColor(noteId, color); palette.remove(); activeColorPalette = null;
                });
                palette.appendChild(option);
            });
            document.body.appendChild(palette);
            const anchorRect = anchorElement.getBoundingClientRect();
            Object.assign(palette.style, { top: `${anchorRect.bottom + 5}px`, left: `${anchorRect.left}px`});
            activeColorPalette = palette;
        }
        function updateNoteColor(noteId, color) {
            const note = notes.find(n => n.id === noteId);
            const noteEl = canvas.querySelector(`.note[data-id="${noteId}"]`);
            if (note && noteEl) {
                note.color = color; noteEl.style.backgroundColor = color;
                noteEl.querySelector('.note-color-picker').style.backgroundColor = color; saveState();
            }
        }

        function updateToolbarState() {
            const isNoteSelected = !!selectedNoteId;
            deleteNoteBtn.disabled = !isNoteSelected;
            Object.values(formattingButtons).forEach(btn => btn.disabled = !isNoteSelected);
        }
        function execCmd(command, value = null) {
            const contentEl = getSelectedNoteContentElement();
            if (!contentEl || document.activeElement !== contentEl) contentEl?.focus();
            document.execCommand(command, false, value);
            if (contentEl) {
                const note = notes.find(n => n.id === selectedNoteId);
                if (note) note.content = contentEl.innerHTML; saveStateDebounced();
            }
            updateFormattingButtonStates();
        }
        function execCmdFormatBlock(tagName) { execCmd('formatBlock', `<${tagName}>`); }
        function createLink() {
            const contentEl = getSelectedNoteContentElement(); if (!contentEl) return;
            if (document.activeElement !== contentEl) contentEl.focus();
            const url = prompt("Enter link URL:", "https://");
            if (url) execCmd('createLink', url);
        }
        function insertChecklistItemFromToolbar() {
            const contentEl = getSelectedNoteContentElement(); if (!contentEl) return;
            if (document.activeElement !== contentEl) contentEl.focus();
            const id = `chk-${Date.now()}`;
            const html = `<div class="checklist-item"><input type="checkbox" id="${id}"><span contenteditable="true">List item</span></div>`;
            document.execCommand('insertHTML', false, html);
            const newSpan = contentEl.querySelector(`#${id}`)?.nextElementSibling;
            if (newSpan) {
                const range = document.createRange(); const sel = window.getSelection();
                range.selectNodeContents(newSpan); range.collapse(false);
                sel.removeAllRanges(); sel.addRange(range); newSpan.focus();
            }
            const note = notes.find(n => n.id === selectedNoteId);
            if (note) note.content = contentEl.innerHTML; saveState();
        }
        function insertInlineCode() { surroundSelection('<code>', '</code>', true); }
        function insertCodeBlock() { surroundSelection('<pre><code>', '</code></pre>', false); }
        function surroundSelection(prefix, suffix, isInline) {
            const contentEl = getSelectedNoteContentElement(); if (!contentEl) return;
            if (document.activeElement !== contentEl) contentEl.focus();
            const sel = window.getSelection();
            if (sel.rangeCount > 0) {
                const range = sel.getRangeAt(0); if (!contentEl.contains(range.commonAncestorContainer)) return;
                const selectedText = sel.toString();
                let replacementHTML = isInline ? `${prefix}${selectedText || "code"}${suffix}` : `${prefix}${selectedText || "\n"}${suffix}`;
                document.execCommand('insertHTML', false, replacementHTML);
                const note = notes.find(n => n.id === selectedNoteId);
                if (note) note.content = contentEl.innerHTML; saveStateDebounced();
            }
        }
        function updateFormattingButtonStates() {
            if (!selectedNoteId) {
                Object.values(formattingButtons).forEach(btn => { btn.classList.remove('active'); btn.disabled = true; }); return;
            }
            Object.values(formattingButtons).forEach(btn => btn.disabled = false);
            const contentEl = getSelectedNoteContentElement();
            if (document.activeElement === contentEl) {
                try {
                    formattingButtons.bold.classList.toggle('active', document.queryCommandState('bold'));
                    formattingButtons.italic.classList.toggle('active', document.queryCommandState('italic'));
                    formattingButtons.underline.classList.toggle('active', document.queryCommandState('underline'));
                    formattingButtons.strikethrough.classList.toggle('active', document.queryCommandState('strikeThrough'));
                    formattingButtons.ul.classList.toggle('active', document.queryCommandState('insertUnorderedList'));
                    formattingButtons.ol.classList.toggle('active', document.queryCommandState('insertOrderedList'));
                    const blockType = document.queryCommandValue('formatBlock').toLowerCase();
                    formattingButtons.h1.classList.toggle('active', blockType === 'h1');
                    formattingButtons.h2.classList.toggle('active', blockType === 'h2');
                    formattingButtons.h3.classList.toggle('active', blockType === 'h3');
                    formattingButtons.quote.classList.toggle('active', blockType === 'blockquote');
                    ['link', 'checklist', 'inlineCode', 'codeBlock'].forEach(k => formattingButtons[k].classList.remove('active'));
                } catch (e) { console.warn("Could not query command state:", e); }
            } else { Object.values(formattingButtons).forEach(btn => btn.classList.remove('active')); }
        }

        // --- Import/Export ---
        function exportCanvasData() {
            const dataToExport = {
                version: EXPORT_VERSION,
                notes: notes,
                transform: { zoomLevel, panX, panY },
                highestZIndex: highestZIndex,
                settings: {
                    theme: localStorage.getItem('modularNotepad_theme_v8') || 'light',
                    gridVisible: localStorage.getItem('modularNotepad_gridVisible_v8') === 'true'
                }
            };
            const jsonString = JSON.stringify(dataToExport, null, 2); // Pretty print
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            a.download = `notepad-canvas-backup-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function handleFileImportSelection(event) {
            const file = event.target.files[0];
            if (file && file.type === "application/json") {
                triggerConfirmImportPopup(file);
            } else if (file) {
                alert("Invalid file type. Please select a .json file.");
                importFilePicker.value = ''; // Reset
            }
        }

        function performActualImport(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    // Basic validation
                    if (!importedData || typeof importedData !== 'object' || !importedData.notes || !importedData.transform || !importedData.settings) {
                        throw new Error("Invalid JSON structure for import.");
                    }
                    // Could add version check here: if (importedData.version !== EXPORT_VERSION) ...

                    notes = importedData.notes.map(note => ({ // Sanitize/default imported notes
                        ...note,
                        x: snapToGrid(parseFloat(note.x) || 0),
                        y: snapToGrid(parseFloat(note.y) || 0),
                        width: snapToGrid(Math.max(parseFloat(note.width) || MIN_NOTE_WIDTH, MIN_NOTE_WIDTH)),
                        height: snapToGrid(Math.max(parseFloat(note.height) || MIN_NOTE_HEIGHT, MIN_NOTE_HEIGHT)),
                        zIndex: parseInt(note.zIndex, 10) || 1,
                        title: note.title || '',
                        content: note.content || ''
                    }));
                    
                    zoomLevel = parseFloat(importedData.transform.zoomLevel) || 1;
                    panX = parseFloat(importedData.transform.panX) || 0;
                    panY = parseFloat(importedData.transform.panY) || 0;
                    highestZIndex = parseInt(importedData.highestZIndex, 10) || (notes.length > 0 ? Math.max(...notes.map(n => n.zIndex || 0), 0) + 1 : 1);

                    applyTheme(importedData.settings.theme || 'light');
                    applyGridVisibility(importedData.settings.gridVisible === true); // Ensure boolean

                    selectedNoteId = null; // Deselect any current note
                    renderNotes();
                    updateCanvasTransform();
                    updateToolbarState();
                    saveState(); // Save the newly imported state to localStorage
                    alert("Canvas imported successfully!");

                } catch (error) {
                    console.error("Error importing file:", error);
                    alert(`Error importing file: ${error.message}`);
                } finally {
                    importFilePicker.value = ''; // Reset file picker
                }
            };
            reader.readAsText(file);
        }


        const LS_APP_PREFIX = 'modularNotepad_';
        const LS_NOTES_KEY = LS_APP_PREFIX + 'notes_v8_io';
        const LS_TRANSFORM_KEY = LS_APP_PREFIX + 'transform_v8';
        const LS_HIGHEST_Z_KEY = LS_APP_PREFIX + 'highestZ_v8';
        const LS_THEME_KEY = LS_APP_PREFIX + 'theme_v8';
        const LS_GRID_VISIBLE_KEY = LS_APP_PREFIX + 'gridVisible_v8';

        let saveTimeout;
        function saveStateDebounced() { clearTimeout(saveTimeout); saveTimeout = setTimeout(saveState, 500); }
        function saveState() {
            clearTimeout(saveTimeout);
            if (notes.some(note => isNaN(note.x) || isNaN(note.y) || isNaN(note.width) || isNaN(note.height) || isNaN(note.zIndex))) {
                console.error("Attempted to save invalid (NaN) note data. Aborting save."); return;
            }
            localStorage.setItem(LS_NOTES_KEY, JSON.stringify(notes));
            localStorage.setItem(LS_TRANSFORM_KEY, JSON.stringify({ zoomLevel, panX, panY }));
            localStorage.setItem(LS_HIGHEST_Z_KEY, highestZIndex.toString());
            // Theme and grid are saved by their respective apply functions, which are called during import too.
        }
        function loadState() {
            const storedNotes = localStorage.getItem(LS_NOTES_KEY);
            if (storedNotes) {
                try {
                    notes = JSON.parse(storedNotes).map(note => ({
                        id: note.id, title: note.title || '', content: note.content || '',
                        x: snapToGrid(parseFloat(note.x) || 0), y: snapToGrid(parseFloat(note.y) || 0),
                        width: snapToGrid(Math.max(parseFloat(note.width) || MIN_NOTE_WIDTH, MIN_NOTE_WIDTH)),
                        height: snapToGrid(Math.max(parseFloat(note.height) || MIN_NOTE_HEIGHT, MIN_NOTE_HEIGHT)),
                        color: note.color, zIndex: parseInt(note.zIndex, 10) || 1
                    }));
                } catch (e) { console.error("Error parsing notes:", e); notes = []; }
            }
            const storedTransform = localStorage.getItem(LS_TRANSFORM_KEY);
            if (storedTransform) {
                try {
                    const t = JSON.parse(storedTransform);
                    zoomLevel = parseFloat(t.zoomLevel) || 1; panX = parseFloat(t.panX) || 0; panY = parseFloat(t.panY) || 0;
                } catch (e) { /* defaults already set */ }
            }
            highestZIndex = parseInt(localStorage.getItem(LS_HIGHEST_Z_KEY), 10) || (notes.length > 0 ? Math.max(...notes.map(n => n.zIndex || 0), 0) + 1 : 1);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (!confirmDeleteModal.classList.contains('hidden')) { hideConfirmDeletePopup(); e.preventDefault(); return; }
                if (!confirmImportModal.classList.contains('hidden')) { hideConfirmImportPopup(); e.preventDefault(); return; }
                if (activeColorPalette) { activeColorPalette.remove(); activeColorPalette = null; e.preventDefault(); return; }
                const activeTitle = document.querySelector('.note-title[contenteditable="true"]');
                if (activeTitle) { activeTitle.blur(); e.preventDefault(); return; }
            }
            const activeEl = document.activeElement;
            const isContentFocused = activeEl && activeEl.classList.contains('note-content') && activeEl.isContentEditable;
            const isTitleFocused = activeEl && activeEl.classList.contains('note-title') && activeEl.isContentEditable;

            if (isContentFocused) {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key.toLowerCase()) {
                        case 'b': e.preventDefault(); execCmd('bold'); break;
                        case 'i': e.preventDefault(); execCmd('italic'); break;
                        case 'u': e.preventDefault(); execCmd('underline'); break;
                    }
                }
                return;
            }
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNoteId && !isContentFocused && !isTitleFocused && confirmDeleteModal.classList.contains('hidden')) {
                e.preventDefault(); triggerDeleteConfirmation();
            }
        });
        
        init();
    </script>
</body>
</html>