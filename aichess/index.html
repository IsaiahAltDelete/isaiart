<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess AI vs AI</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Roboto:wght@300;400;500&family=Roboto+Mono&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        :root {
            /* Color Palette */
            --primary: #1a237e;
            --primary-light: #534bae;
            --primary-dark: #000051;
            --secondary: #009688;
            --accent: #ffc107;
            --bg-color: #f5f5f5;
            --container-bg: #ffffff;
            --text-color: #212121;
            --text-secondary: #757575;
            --square-light: #d2b48c;
            --square-dark: #8b4513;
            --highlight-color: rgba(255, 193, 7, 0.5);
            --card-bg: #ffffff;
            --card-active-bg: #f1f1f1;
            --border-color: #e0e0e0;
            --button-bg: var(--primary);
            --button-text: white;
            --button-hover: var(--primary-light);
            --button-disabled: #bdbdbd;
            --draw-button: #546e7a;
            --resign-button: #d32f2f;
            --theme-button: #37474f;
            --infinite-button: #388e3c;
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.12);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.15);
            --transition-fast: all 0.2s ease;
            --transition-medium: all 0.3s ease;
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
        }
        
        .dark-theme {
            --primary: #5c6bc0;
            --primary-light: #8e99f3;
            --primary-dark: #26418f;
            --bg-color: #121212;
            --container-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --text-secondary: #b0b0b0;
            --square-light: #8d795b;
            --square-dark: #5d3726;
            --highlight-color: rgba(255, 193, 7, 0.3);
            --card-bg: #2d2d2d;
            --card-active-bg: #3d3d3d;
            --border-color: #444444;
            --button-bg: var(--primary);
            --button-disabled: #444444;
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.2);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.25);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.3);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            min-height: 100vh;
            margin: 0;
            color: var(--text-color);
            transition: var(--transition-medium);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
            grid-template-rows: auto auto 1fr auto;
            gap: 24px;
            max-width: 1300px;
            width: 95%;
            padding: 32px;
            background-color: var(--container-bg);
            box-shadow: var(--shadow-lg);
            border-radius: var(--radius-lg);
            transition: var(--transition-medium);
        }
        
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Montserrat', sans-serif;
            color: var(--text-color);
            transition: var(--transition-medium);
        }
        
        h1 {
            grid-column: 1 / -1;
            text-align: center;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 28px;
            letter-spacing: -0.5px;
            position: relative;
            padding-bottom: 10px;
            transition: var(--transition-medium);
        }
        
        h1::after {
            content: '';
            position: absolute;
            left: 50%;
            bottom: 0;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background-color: var(--accent);
            border-radius: 3px;
        }
        
        .game-area {
            grid-column: 1;
            grid-row: 2 / 4;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .thinking-area {
            grid-column: 2;
            grid-row: 2 / 4;
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 16px;
        }
        
        .card {
            background-color: var(--card-bg);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            transition: var(--transition-medium);
        }
        
        .player-card {
            display: grid;
            grid-template-columns: auto 1fr;
            grid-template-rows: auto auto auto;
            gap: 8px;
            padding: 16px;
            border-radius: var(--radius-md);
            width: 100%;
            margin-bottom: 8px;
            transition: var(--transition-medium);
            background-color: var(--card-bg);
            box-shadow: var(--shadow-sm);
            border-left: 4px solid transparent;
            position: relative;
            overflow: hidden;
        }
        
        .player-card.active {
            background-color: var(--card-active-bg);
            box-shadow: var(--shadow-md);
            border-left-color: var(--accent);
        }
        
        .player-card.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background-color: var(--accent);
        }
        
        .player-avatar {
            grid-row: 1 / 4;
            grid-column: 1;
            font-size: 32px;
            width: 56px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--card-active-bg);
            border-radius: 50%;
            box-shadow: var(--shadow-sm);
            margin-right: 16px;
            transition: var(--transition-medium);
            border: 2px solid transparent;
        }
        
        .player-card.active .player-avatar {
            background-color: var(--accent);
            color: #000;
            border-color: #fff;
            transform: scale(1.05);
        }
        
        .player-name {
            grid-row: 1;
            grid-column: 2;
            font-size: 18px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            color: var(--text-color);
            transition: var(--transition-medium);
        }
        
        .player-timer {
            grid-row: 2;
            grid-column: 2;
            font-size: 26px;
            font-family: 'Roboto Mono', monospace;
            font-weight: 400;
            color: var(--secondary);
            transition: var(--transition-medium);
            letter-spacing: 1px;
        }
        
        .win-count {
            grid-row: 3;
            grid-column: 2;
            font-size: 14px;
            color: var(--text-secondary);
            transition: var(--transition-medium);
        }
        
        .thinking-box {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            background-color: var(--card-bg);
            border-radius: var(--radius-md);
            border-left: 4px solid transparent;
            opacity: 0.85;
            transition: var(--transition-medium);
            color: var(--text-color);
            box-shadow: var(--shadow-sm);
            position: relative;
        }
        
        .thinking-box.active {
            opacity: 1;
            border-left-color: var(--accent);
            box-shadow: var(--shadow-md);
        }
        
        .thinking-title {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            color: var(--text-color);
            font-size: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .thinking-title span {
            margin-left: 12px;
            font-size: 13px;
            font-weight: normal;
            animation: thinking 1.2s infinite;
            color: var(--accent);
        }
        
        @keyframes thinking {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }
        
        .thinking-content {
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-color);
        }
        
        .move-consideration {
            margin-bottom: 14px;
            padding-left: 16px;
            border-left: 2px solid var(--border-color);
            transition: var(--transition-medium);
        }
        
        .move-consideration strong {
            color: var(--secondary);
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 14px;
            display: block;
            margin-bottom: 4px;
        }
        
        .chessboard {
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1 / 1;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 3px solid var(--primary-dark);
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-lg);
            position: relative;
            overflow: hidden;
        }
        
        .coordinates {
            position: absolute;
            color: var(--text-secondary);
            font-size: 12px;
            font-family: 'Roboto Mono', monospace;
            font-weight: 500;
            transition: var(--transition-medium);
        }
        
        .coordinate-file {
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .coordinate-rank {
            right: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            cursor: default;
            transition: background-color 0.2s;
            position: relative;
        }
        
        .square.white {
            background-color: var(--square-light);
        }
        
        .square.black {
            background-color: var(--square-dark);
        }
        
        .square.highlight {
            position: relative;
        }
        
        .square.highlight::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--highlight-color);
            z-index: 1;
        }
        
        .piece {
            width: 90%;
            height: 90%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            position: relative;
            z-index: 2;
            filter: drop-shadow(1px 1px 1px rgba(0, 0, 0, 0.5));
            font-size: 0.9em;
        }
        
        .piece-moving {
            animation: piece-move 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            z-index: 10;
        }
        
        @keyframes piece-move {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-20px) scale(1.25); }
            100% { transform: translateY(0) scale(1); }
        }
        
        .piece-white {
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
        }
        
        .piece-black {
            color: #000000;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.3);
        }
        
        .piece-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 12px;
            font-family: 'Montserrat', sans-serif;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
            z-index: 20;
        }
        
        .piece:hover .piece-tooltip {
            opacity: 1;
            visibility: visible;
        }
        
        .captured-pieces {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            width: 100%;
            gap: 16px;
        }
        
        .captured-display {
            position: relative;
            padding: 12px 16px;
            background-color: var(--card-bg);
            border-radius: var(--radius-md);
            min-height: 46px;
            width: 48%;
            cursor: pointer;
            text-align: center;
            transition: var(--transition-medium);
            box-shadow: var(--shadow-sm);
        }
        
        .captured-display:hover {
            background-color: var(--card-active-bg);
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }
        
        .captured-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Montserrat', sans-serif;
        }
        
        .captured-title:after {
            content: '▼';
            font-size: 10px;
            margin-left: 5px;
            opacity: 0.7;
            transition: var(--transition-fast);
        }
        
        .captured-display:hover .captured-title:after {
            transform: rotate(180deg);
        }
        
        .captured-count {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background-color: var(--accent);
            color: #000;
            font-size: 12px;
            font-weight: 600;
            border-radius: 12px;
            min-width: 24px;
            height: 24px;
            text-align: center;
            padding: 0 8px;
            margin-left: 8px;
            transition: var(--transition-medium);
        }
        
        .captured-popup {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            width: 100%;
            background-color: var(--container-bg);
            border-radius: var(--radius-md);
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            z-index: 100;
            box-shadow: var(--shadow-md);
            opacity: 0;
            visibility: hidden;
            transition: var(--transition-medium);
            max-height: 0;
            overflow: hidden;
            justify-content: center;
            align-items: center;
        }
        
        .captured-display:hover .captured-popup {
            opacity: 1;
            visibility: visible;
            max-height: 200px;
            padding: 12px;
        }
        
        .captured-piece {
            margin: 0 4px;
            font-size: 28px;
            line-height: 1;
            filter: drop-shadow(1px 1px 1px rgba(0, 0, 0, 0.3));
        }
        
        .no-pieces {
            font-style: italic;
            opacity: 0.7;
            font-size: 13px;
            padding: 8px;
            color: var(--text-secondary);
        }
        
        .controls {
            grid-column: 1 / -1;
            grid-row: 4;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 10px;
        }
        
        button {
            padding: 10px 18px;
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 500;
            transition: var(--transition-medium);
            box-shadow: var(--shadow-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            letter-spacing: 0.3px;
            min-width: 110px;
        }
        
        button:hover {
            background-color: var(--button-hover);
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }
        
        button:disabled {
            background-color: var(--button-disabled);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.7;
        }
        
        button.draw-btn {
            background-color: var(--draw-button);
        }
        
        button.resign-btn {
            background-color: var(--resign-button);
        }
        
        button.theme-btn {
            background-color: var(--theme-button);
        }
        
        button.infinite-btn {
            background-color: var(--infinite-button);
        }
        
        button.active {
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5) inset;
            font-weight: 600;
        }
        
        button svg {
            margin-right: 6px;
            width: 16px;
            height: 16px;
        }
        
        .move-history {
            width: 100%;
            max-height: 140px;
            overflow-y: auto;
            margin-top: 20px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 12px;
            font-family: 'Roboto Mono', monospace;
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--card-bg);
            transition: var(--transition-medium);
        }
        
        .dialogue-box {
            padding: 12px 16px;
            background-color: var(--card-bg);
            border-radius: var(--radius-md);
            width: 100%;
            min-height: 46px;
            text-align: center;
            font-style: italic;
            font-size: 14px;
            margin-top: 20px;
            color: var(--text-color);
            box-shadow: var(--shadow-sm);
            transition: var(--transition-medium);
            border-left: 4px solid var(--secondary);
        }
        
        .typing-animation {
            overflow: hidden;
            border-right: .15em solid var(--accent);
            white-space: nowrap;
            margin: 0;
            animation: typing 3.5s steps(40, end), blink-caret .75s step-end infinite;
        }
        
        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }
        
        @keyframes blink-caret {
            from, to { border-color: transparent }
            50% { border-color: var(--accent); }
        }
        
        /* Responsive Design */
        @media (max-width: 1000px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto auto;
                width: 98%;
                padding: 20px;
                gap: 16px;
            }
            
            .game-area {
                grid-column: 1;
                grid-row: 2;
            }
            
            .thinking-area {
                grid-column: 1;
                grid-row: 3;
                max-height: 400px;
                overflow-y: auto;
            }
            
            .controls {
                grid-row: 4;
            }
            
            .chessboard {
                max-width: 400px;
            }
            
            button {
                padding: 8px 12px;
                font-size: 13px;
                min-width: auto;
            }
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 15px;
                gap: 12px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            .thinking-area {
                max-height: 300px;
            }
            
            .chessboard {
                max-width: 100%;
            }
            
            .controls {
                gap: 8px;
            }
            
            button {
                padding: 8px 10px;
                font-size: 12px;
            }
            
            .player-card {
                padding: 12px;
            }
            
            .player-avatar {
                width: 46px;
                height: 46px;
                font-size: 24px;
            }
            
            .player-name {
                font-size: 16px;
            }
            
            .player-timer {
                font-size: 22px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chess AI Battle</h1>
        
        <div class="game-area">
            <div class="chessboard" id="board"></div>
            
            <div class="captured-pieces">
                <div class="captured-display" id="captured-black-display">
                    <div class="captured-title">Black pieces captured <span class="captured-count" id="black-captured-count">0</span></div>
                    <div class="captured-popup" id="captured-black">
                        <div class="no-pieces">No pieces captured yet</div>
                    </div>
                </div>
                <div class="captured-display" id="captured-white-display">
                    <div class="captured-title">White pieces captured <span class="captured-count" id="white-captured-count">0</span></div>
                    <div class="captured-popup" id="captured-white">
                        <div class="no-pieces">No pieces captured yet</div>
                    </div>
                </div>
            </div>
            
            <div class="dialogue-box" id="dialogue">Game ready to start. Press "New Game" to begin.</div>
            
            <div class="move-history" id="move-history"></div>
        </div>
        
        <div class="thinking-area">
            <div class="player-card" id="white-player">
                <div class="player-avatar">♔</div>
                <div class="player-name">Stockfish</div>
                <div class="player-timer" id="white-timer">05:00</div>
                <div class="win-count" id="white-wins">Wins: 0</div>
            </div>
            
            <div class="thinking-box" id="white-thinking-box">
                <div class="thinking-title">Stockfish Analysis <span id="white-thinking-indicator"></span></div>
                <div class="thinking-content" id="white-thinking-content"></div>
            </div>
            
            <div class="player-card" id="black-player">
                <div class="player-avatar">♚</div>
                <div class="player-name">DeepChess</div>
                <div class="player-timer" id="black-timer">05:00</div>
                <div class="win-count" id="black-wins">Wins: 0</div>
            </div>
            
            <div class="thinking-box" id="black-thinking-box">
                <div class="thinking-title">DeepChess Analysis <span id="black-thinking-indicator"></span></div>
                <div class="thinking-content" id="black-thinking-content"></div>
            </div>
        </div>
        
        <div class="controls">
            <button id="start-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                New Game
            </button>
            <button id="pause-btn" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                Pause
            </button>
            <button id="draw-btn" class="draw-btn" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                Offer Draw
            </button>
            <button id="resign-btn" class="resign-btn" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 2.1l4 4-4 4"/><path d="M3 12.2v-2a4 4 0 0 1 4-4h12.8M7 21.9l-4-4 4-4"/><path d="M21 11.8v2a4 4 0 0 1-4 4H4.2"/></svg>
                Resign
            </button>
            <button id="speed-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
                Normal
            </button>
            <button id="theme-btn" class="theme-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                Dark Theme
            </button>
            <button id="infinite-btn" class="infinite-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18.178 8c5.076 0 5.076 8 0 8h-6.351"></path><path d="M13.65 16c-5.075 0-5.075-8 0-8h6.351"></path></svg>
                Infinite Mode
            </button>
        </div>
    </div>

    <script>
        // Chess piece representations using Unicode chess symbols
        const PIECES = {
            'wP': '♙', 'wR': '♖', 'wN': '♘', 'wB': '♗', 'wQ': '♕', 'wK': '♔',
            'bP': '♟', 'bR': '♜', 'bN': '♞', 'bB': '♝', 'bQ': '♛', 'bK': '♚'
        };
        
        // Game configuration
        let gameConfig = {
            speed: 'normal', // slow, normal, fast
            whiteThinkingTime: { min: 1000, max: 3000 },
            blackThinkingTime: { min: 1000, max: 3000 },
            gameInProgress: false,
            gamePaused: false,
            wins: { white: 0, black: 0 },
            timers: { white: 300, black: 300 }, // 5 minutes per player
            activeTimer: null,
            lastMoveTime: null,
            moveDelay: 500, // ms before showing the move after "thinking"
            highlightSquares: [],
            capturedPieces: { white: [], black: [] },
            lastPosition: null, // To track piece movements
            entropyFactor: 0.2, // 0-1 scale, higher means more random play
            darkTheme: false,
            infiniteMode: false,
            openingVariations: [
                ["e4", "e5", "Nf3", "Nc6"], // King's Pawn Opening
                ["d4", "d5", "c4", "e6"],    // Queen's Gambit
                ["e4", "c5", "Nf3", "d6"],   // Sicilian Defense
                ["d4", "Nf6", "c4", "g6"],   // King's Indian Defense
                ["Nf3", "Nf6", "c4", "e6"],  // English Opening
                ["e4", "e6", "d4", "d5"]     // French Defense
            ]
        };
        
        // Speed presets
        const SPEED_PRESETS = {
            slow: { 
                white: { min: 2000, max: 5000 },
                black: { min: 2000, max: 5000 },
                moveDelay: 1000
            },
            normal: { 
                white: { min: 1000, max: 3000 },
                black: { min: 1000, max: 3000 },
                moveDelay: 500
            },
            fast: { 
                white: { min: 300, max: 1000 },
                black: { min: 300, max: 1000 },
                moveDelay: 200
            }
        };
        
        // Chess notation helper
        const FILE_NAMES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
        const RANK_NAMES = ['1', '2', '3', '4', '5', '6', '7', '8'];
        const PIECE_NAMES = {
            p: 'pawn', r: 'rook', n: 'knight', b: 'bishop', q: 'queen', k: 'king'
        };
        
        // AI "personalities" and dialogue options
        const AI_DIALOGUE = {
            white: {
                thinking: ["Analyzing position...", "Calculating variations...", "Evaluating position..."],
                positions: [
                    "Control of the center is key here.",
                    "The pawn structure suggests a strategic advantage.",
                    "Knight outpost on {square} looks promising.",
                    "Pressure on the {file} file is building.",
                    "The {color} bishop pair provides long-term advantage.",
                    "Rook activity on the 7th rank is decisive.",
                    "Queen side majority can be exploited."
                ],
                tactics: [
                    "Looking for tactical shots against the {piece} on {square}.",
                    "Double attack on {square1} and {square2} possible.",
                    "Pin against the {piece} on {square} can be exploited.",
                    "Sacrifice on {square} might open lines to the king.",
                    "Knight fork opportunity after {move}.",
                    "Discovered attack after moving the {piece}."
                ],
                moves: [
                    "Considering {move1}, {move2}, and {move3}...",
                    "{move1} improves piece activity.",
                    "{move1} controls critical squares.",
                    "{move1} threatens {threat}.",
                    "{move1} creates weaknesses around the enemy king.",
                    "{move1} improves pawn structure.",
                    "After {move1}, planning to follow with {move2}."
                ]
            },
            black: {
                thinking: ["Processing board state...", "Computing optimal move...", "Searching for tactics..."],
                positions: [
                    "Knight maneuver to {square} controls key central squares.",
                    "Pawn break at {square} disrupts white's structure.",
                    "Fianchetto development provides long-term advantage.",
                    "Exchange of dark-squared bishops favors our position.",
                    "Pressure along the {file} file creates tactical opportunities.",
                    "King safety is priority with the open center.",
                    "Minority attack on queenside underway."
                ],
                tactics: [
                    "Tactical motif: deflection of the defender at {square}.",
                    "Zwischenzug opportunity before capturing on {square}.",
                    "Preparing a discovered check by moving the {piece}.",
                    "Back rank weakness can be exploited with {move}.",
                    "The {piece} on {square} is overloaded defending multiple threats.",
                    "Potential sacrifice on {square} to open attacking lines."
                ],
                moves: [
                    "Main candidates: {move1}, {move2}, and {move3}.",
                    "{move1} improves my piece coordination.",
                    "{move1} prevents white's plan of {threat}.",
                    "After {move1}, the position becomes tactically sharp.",
                    "{move1} followed by {move2} creates counterplay.",
                    "{move1} neutralizes white's initiative.",
                    "Prophylactic {move1} prevents white's ideas."
                ]
            }
        };
        
        // Initialize elements
        const board = document.getElementById('board');
        const moveHistory = document.getElementById('move-history');
        const dialogueBox = document.getElementById('dialogue');
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const drawBtn = document.getElementById('draw-btn');
        const resignBtn = document.getElementById('resign-btn');
        const speedBtn = document.getElementById('speed-btn');
        const themeBtn = document.getElementById('theme-btn');
        const infiniteBtn = document.getElementById('infinite-btn');
        const whiteTimer = document.getElementById('white-timer');
        const blackTimer = document.getElementById('black-timer');
        const whiteThinkingBox = document.getElementById('white-thinking-box');
        const blackThinkingBox = document.getElementById('black-thinking-box');
        const whiteThinkingContent = document.getElementById('white-thinking-content');
        const blackThinkingContent = document.getElementById('black-thinking-content');
        const whiteThinkingIndicator = document.getElementById('white-thinking-indicator');
        const blackThinkingIndicator = document.getElementById('black-thinking-indicator');
        const whitePlayer = document.getElementById('white-player');
        const blackPlayer = document.getElementById('black-player');
        const whiteWins = document.getElementById('white-wins');
        const blackWins = document.getElementById('black-wins');
        const capturedBlack = document.getElementById('captured-black');
        const capturedWhite = document.getElementById('captured-white');
        const blackCapturedCount = document.getElementById('black-captured-count');
        const whiteCapturedCount = document.getElementById('white-captured-count');
        
        // Initialize chess.js
        let chess = new Chess();
        
        // Function to create the chessboard
        function createBoard() {
            board.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    const squareColor = (row + col) % 2 === 0 ? 'white' : 'black';
                    square.className = `square ${squareColor}`;
                    square.dataset.row = 7 - row; // Flipped to match chess.js coordinates
                    square.dataset.col = col;
                    
                    // Add coordinates to edge squares
                    if (row === 7) {
                        const fileLabel = document.createElement('div');
                        fileLabel.className = 'coordinates coordinate-file';
                        fileLabel.textContent = FILE_NAMES[col];
                        square.appendChild(fileLabel);
                    }
                    if (col === 7) {
                        const rankLabel = document.createElement('div');
                        rankLabel.className = 'coordinates coordinate-rank';
                        rankLabel.textContent = RANK_NAMES[7 - row];
                        square.appendChild(rankLabel);
                    }
                    
                    board.appendChild(square);
                }
            }
            updateBoard();
        }
        
        // Function to update the board with current game state
        function updateBoard() {
            // Save current position for animation
            gameConfig.lastPosition = captureCurrentPosition();
            
            // Clear all pieces
            document.querySelectorAll('.piece').forEach(piece => piece.remove());
            
            // Clear highlights
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('highlight');
            });
            
            // Add highlights for the last move
            gameConfig.highlightSquares.forEach(squareId => {
                const [col, row] = squareId.split('');
                const square = document.querySelector(`.square[data-col="${col.charCodeAt(0) - 97}"][data-row="${row - 1}"]`);
                if (square) square.classList.add('highlight');
            });
            
            // Add pieces based on current position
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = chess.board()[row][col];
                    if (square) {
                        const piece = document.createElement('div');
                        piece.className = `piece piece-${square.color === 'w' ? 'white' : 'black'}`;
                        const pieceType = square.color + square.type.toUpperCase();
                        piece.textContent = PIECES[pieceType];
                        
                        // Add tooltip with piece name
                        const tooltip = document.createElement('div');
                        tooltip.className = 'piece-tooltip';
                        tooltip.textContent = `${square.color === 'w' ? 'White' : 'Black'} ${PIECE_NAMES[square.type]}`;
                        piece.appendChild(tooltip);
                        
                        const squareElement = document.querySelector(`.square[data-col="${col}"][data-row="${7 - row}"]`);
                        if (squareElement) {
                            // Check if this is the piece that moved
                            if (gameConfig.highlightSquares.length === 2 && 
                                getSquareNotation(col, 7-row) === gameConfig.highlightSquares[1]) {
                                piece.classList.add('piece-moving');
                            }
                            squareElement.appendChild(piece);
                        }
                    }
                }
            }
            
            // Update captured pieces display
            updateCapturedPieces();
        }
        
        // Function to update captured pieces display
        function updateCapturedPieces() {
            // Clear displays
            capturedWhite.innerHTML = '';
            capturedBlack.innerHTML = '';
            
            // Update counters
            whiteCapturedCount.textContent = gameConfig.capturedPieces.white.length;
            blackCapturedCount.textContent = gameConfig.capturedPieces.black.length;
            
            // If no pieces captured, show message
            if (gameConfig.capturedPieces.white.length === 0) {
                capturedWhite.innerHTML = '<div class="no-pieces">No pieces captured yet</div>';
            } else {
                // Group pieces by type for more organized display
                const whitePieces = groupPiecesByType(gameConfig.capturedPieces.white);
                
                // Add pieces to display
                Object.entries(whitePieces).forEach(([piece, count]) => {
                    for (let i = 0; i < count; i++) {
                        const capturedPiece = document.createElement('div');
                        capturedPiece.className = 'captured-piece piece-white';
                        capturedPiece.textContent = PIECES['w' + piece.toUpperCase()];
                        capturedWhite.appendChild(capturedPiece);
                    }
                });
            }
            
            // Same for black pieces
            if (gameConfig.capturedPieces.black.length === 0) {
                capturedBlack.innerHTML = '<div class="no-pieces">No pieces captured yet</div>';
            } else {
                const blackPieces = groupPiecesByType(gameConfig.capturedPieces.black);
                
                Object.entries(blackPieces).forEach(([piece, count]) => {
                    for (let i = 0; i < count; i++) {
                        const capturedPiece = document.createElement('div');
                        capturedPiece.className = 'captured-piece piece-black';
                        capturedPiece.textContent = PIECES['b' + piece.toUpperCase()];
                        capturedBlack.appendChild(capturedPiece);
                    }
                });
            }
        }
        
        // Helper function to group pieces by type
        function groupPiecesByType(pieces) {
            const result = {};
            pieces.forEach(piece => {
                if (!result[piece]) {
                    result[piece] = 0;
                }
                result[piece]++;
            });
            return result;
        }
        
        // Helper function to capture current board position
        function captureCurrentPosition() {
            const position = [];
            for (let row = 0; row < 8; row++) {
                position[row] = [];
                for (let col = 0; col < 8; col++) {
                    position[row][col] = chess.board()[row][col];
                }
            }
            return position;
        }
        
        // Helper function to get square notation (e.g., "e4") from coordinates
        function getSquareNotation(col, row) {
            return FILE_NAMES[col] + (row + 1);
        }
        
        // Function to update the move history display
        function updateMoveHistory() {
            const history = chess.history({ verbose: true });
            let historyText = '';
            
            for (let i = 0; i < history.length; i += 2) {
                const moveNum = Math.floor(i / 2) + 1;
                const whiteMove = history[i] ? `${history[i].san}` : '';
                const blackMove = history[i + 1] ? `${history[i + 1].san}` : '';
                
                historyText += `${moveNum}. ${whiteMove.padEnd(7)} ${blackMove}\n`;
            }
            
            moveHistory.textContent = historyText;
            moveHistory.scrollTop = moveHistory.scrollHeight;
        }
        
        // Function to update timer display
        function updateTimerDisplay() {
            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            };
            
            whiteTimer.textContent = formatTime(gameConfig.timers.white);
            blackTimer.textContent = formatTime(gameConfig.timers.black);
        }
        
        // Timer logic
        function startTimer(color) {
            stopTimer();
            
            if (gameConfig.gamePaused) return;
            
            // Update active player highlight
            whitePlayer.classList.toggle('active', color === 'w');
            blackPlayer.classList.toggle('active', color === 'b');
            whiteThinkingBox.classList.toggle('active', color === 'w');
            blackThinkingBox.classList.toggle('active', color === 'b');
            
            gameConfig.activeTimer = setInterval(() => {
                if (color === 'w') {
                    gameConfig.timers.white--;
                    if (gameConfig.timers.white <= 0) {
                        endGame('black', 'timeout');
                    }
                } else {
                    gameConfig.timers.black--;
                    if (gameConfig.timers.black <= 0) {
                        endGame('white', 'timeout');
                    }
                }
                updateTimerDisplay();
            }, 1000);
        }
        
        function stopTimer() {
            if (gameConfig.activeTimer) {
                clearInterval(gameConfig.activeTimer);
                gameConfig.activeTimer = null;
            }
        }
        
        // Function to simulate typing animation
        function typeText(element, text, speed = 20) {
            element.innerHTML = '';
            
            return new Promise(resolve => {
                let i = 0;
                const timer = setInterval(() => {
                    if (i < text.length) {
                        element.innerHTML += text.charAt(i);
                        i++;
                    } else {
                        clearInterval(timer);
                        resolve();
                    }
                }, speed);
            });
        }
        
        // Function to generate thinking content for AI with typing animation
        async function generateThinkingContent(color) {
            const dialogueOptions = color === 'w' ? AI_DIALOGUE.white : AI_DIALOGUE.black;
            const legalMoves = chess.moves({ verbose: true });
            
            if (legalMoves.length === 0) return '';
            
            // Apply entropy to move selection
            const entropy = gameConfig.entropyFactor;
            
            // Sort moves by piece value for "best moves" consideration
            // with some randomness based on entropy factor
            const sortedMoves = [...legalMoves].sort((a, b) => {
                const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9 };
                const aValue = a.captured ? pieceValues[a.captured] : 0;
                const bValue = b.captured ? pieceValues[b.captured] : 0;
                
                // Add randomness based on entropy factor
                const randomFactor = entropy * (Math.random() * 2 - 1);
                return (bValue - aValue) + randomFactor;
            });
            
            // Pick top 3 "candidate" moves for the thinking
            const candidateMoves = sortedMoves.slice(0, Math.min(3, sortedMoves.length));
            
            // Generate the thinking content
            let content = '';
            const thinkingContent = color === 'w' ? whiteThinkingContent : blackThinkingContent;
            
            // Position assessment
            const positionTemplate = dialogueOptions.positions[Math.floor(Math.random() * dialogueOptions.positions.length)];
            let positionText = positionTemplate;
            
            // Replace tokens in position text
            positionText = positionText.replace('{square}', getRandomSquare());
            positionText = positionText.replace('{file}', FILE_NAMES[Math.floor(Math.random() * 8)]);
            positionText = positionText.replace('{color}', color === 'w' ? 'white' : 'black');
            
            thinkingContent.innerHTML = '<div class="move-consideration"><strong>Position assessment:</strong> <span class="typing-text"></span></div>';
            let typingElement = thinkingContent.querySelector('.typing-text');
            await typeText(typingElement, positionText, 10);
            
            // Tactical opportunities
            const tacticTemplate = dialogueOptions.tactics[Math.floor(Math.random() * dialogueOptions.tactics.length)];
            let tacticText = tacticTemplate;
            
            // Replace tokens in tactic text
            tacticText = tacticText.replace('{square}', getRandomSquare());
            tacticText = tacticText.replace('{square1}', getRandomSquare());
            tacticText = tacticText.replace('{square2}', getRandomSquare());
            tacticText = tacticText.replace('{piece}', getRandomPieceName());
            
            thinkingContent.innerHTML += '<div class="move-consideration"><strong>Tactical opportunities:</strong> <span class="typing-text"></span></div>';
            typingElement = thinkingContent.querySelectorAll('.typing-text')[1];
            await typeText(typingElement, tacticText, 10);
            
            // Move considerations
            const moveTemplate = dialogueOptions.moves[Math.floor(Math.random() * dialogueOptions.moves.length)];
            let moveText = moveTemplate;
            
            // Replace move tokens
            const moveNotations = candidateMoves.map(m => m.san);
            moveText = moveText.replace('{move1}', moveNotations[0] || 'e4');
            moveText = moveText.replace('{move2}', moveNotations[1] || 'd4');
            moveText = moveText.replace('{move3}', moveNotations[2] || 'Nf3');
            moveText = moveText.replace('{threat}', getRandomThreat());
            
            thinkingContent.innerHTML += '<div class="move-consideration"><strong>Move analysis:</strong> <span class="typing-text"></span></div>';
            typingElement = thinkingContent.querySelectorAll('.typing-text')[2];
            await typeText(typingElement, moveText, 10);
            
            // If in check, add special consideration
            if (chess.in_check()) {
                thinkingContent.innerHTML += '<div class="move-consideration"><strong>Alert:</strong> <span class="typing-text"></span></div>';
                typingElement = thinkingContent.querySelectorAll('.typing-text')[3];
                await typeText(typingElement, "King is in check! Prioritizing defensive moves.", 10);
            }
            
            // Add evaluation
            const evaluation = Math.random() * 2 - 1; // Random value between -1 and 1
            const evalText = evaluation > 0 ? 
                `Evaluation: +${evaluation.toFixed(2)} (${color === 'w' ? 'White' : 'Black'} is better)` :
                `Evaluation: ${evaluation.toFixed(2)} (${color === 'w' ? 'Black' : 'White'} is better)`;
            
            thinkingContent.innerHTML += '<div class="move-consideration"><strong>Engine evaluation:</strong> <span class="typing-text"></span></div>';
            typingElement = thinkingContent.querySelectorAll('.typing-text')[thinkingContent.querySelectorAll('.typing-text').length - 1];
            await typeText(typingElement, evalText, 10);
            
            return content; // Return is not used but we keep it for consistency
        }
        
        // Helper functions for thinking content
        function getRandomSquare() {
            const file = FILE_NAMES[Math.floor(Math.random() * 8)];
            const rank = RANK_NAMES[Math.floor(Math.random() * 8)];
            return file + rank;
        }
        
        function getRandomPieceName() {
            const pieces = ['pawn', 'knight', 'bishop', 'rook', 'queen', 'king'];
            return pieces[Math.floor(Math.random() * pieces.length)];
        }
        
        function getRandomThreat() {
            const threats = [
                'discovered check', 'fork', 'pin', 'skewer',
                'back rank mate', 'queen capture', 'pawn promotion',
                'piece infiltration', 'king attack'
            ];
            return threats[Math.floor(Math.random() * threats.length)];
        }
        
        // AI move generation with entropy factor
        function findAiMove(color) {
            const legalMoves = chess.moves({ verbose: true });
            
            if (legalMoves.length === 0) return null;
            
            // Check if we're in the opening and should use an opening book
            if (chess.history().length < 8) { // First 4 moves from each side
                // Random chance to follow opening book based on entropy
                if (Math.random() > gameConfig.entropyFactor) {
                    // Select a random opening variation
                    const variation = gameConfig.openingVariations[Math.floor(Math.random() * gameConfig.openingVariations.length)];
                    const moveIndex = chess.history().length;
                    
                    // If we have a book move for this position
                    if (moveIndex < variation.length) {
                        const bookMove = variation[moveIndex];
                        
                        // Try to find this move in legal moves
                        const foundMove = legalMoves.find(m => m.san === bookMove);
                        if (foundMove) {
                            return foundMove;
                        }
                    }
                }
            }
            
            // Weight moves based on piece captured and check, plus entropy factor
            const weightedMoves = legalMoves.map(move => {
                let weight = 1;
                
                // Prioritize captures based on piece value
                if (move.captured) {
                    const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9 };
                    weight += pieceValues[move.captured] * 2;
                }
                
                // Prioritize checks and checkmate
                if (move.san.includes('+')) weight += 3;
                if (move.san.includes('#')) weight += 100;
                
                // Slightly prioritize center control for pawns in the opening
                if (move.piece === 'p' && chess.history().length < 10) {
                    const targetFile = move.to.charAt(0);
                    const targetRank = parseInt(move.to.charAt(1));
                    if ('cdef'.includes(targetFile) && (targetRank === 4 || targetRank === 5)) {
                        weight += 0.5;
                    }
                }
                
                // Add random entropy factor
                weight += (Math.random() * 2 - 1) * gameConfig.entropyFactor * 3;
                
                return { move, weight };
            });
            
            // Calculate total weight
            const totalWeight = weightedMoves.reduce((sum, move) => sum + move.weight, 0);
            
            // Choose a move based on weights
            let randomValue = Math.random() * totalWeight;
            for (const weightedMove of weightedMoves) {
                randomValue -= weightedMove.weight;
                if (randomValue <= 0) {
                    return weightedMove.move;
                }
            }
            
            // Fallback to a random move
            return legalMoves[Math.floor(Math.random() * legalMoves.length)];
        }
        
        // Function to make an AI move with "thinking" animation
        async function makeAiMove() {
            if (!gameConfig.gameInProgress || gameConfig.gamePaused) return;
            
            const currentPlayer = chess.turn();
            const thinkingIndicator = currentPlayer === 'w' ? whiteThinkingIndicator : blackThinkingIndicator;
            const thinkingContent = currentPlayer === 'w' ? whiteThinkingContent : blackThinkingContent;
            const dialogueOptions = currentPlayer === 'w' ? AI_DIALOGUE.white : AI_DIALOGUE.black;
            
            // Clear previous thinking content
            thinkingContent.innerHTML = '';
            
            // Set thinking indicator
            thinkingIndicator.textContent = dialogueOptions.thinking[Math.floor(Math.random() * dialogueOptions.thinking.length)];
            
            // Calculate thinking time based on game speed
            const thinkingTimeConfig = currentPlayer === 'w' ? gameConfig.whiteThinkingTime : gameConfig.blackThinkingTime;
            const thinkingTime = Math.floor(Math.random() * (thinkingTimeConfig.max - thinkingTimeConfig.min)) + thinkingTimeConfig.min;
            
            // Simulate "thinking" - generate and display thinking content
            await generateThinkingContent(currentPlayer);
            
            setTimeout(async () => {
                if (!gameConfig.gameInProgress || gameConfig.gamePaused) return;
                
                const aiMove = findAiMove(currentPlayer);
                if (!aiMove) return;
                
                // Update thinking indicator to show decision
                thinkingIndicator.textContent = "Move decided!";
                
                // Process the move after a short delay
                setTimeout(() => {
                    if (!gameConfig.gameInProgress || gameConfig.gamePaused) return;
                    
                    // Check if this move captures a piece
                    if (aiMove.captured) {
                        // Add to captured pieces
                        if (currentPlayer === 'w') {
                            gameConfig.capturedPieces.black.push(aiMove.captured);
                        } else {
                            gameConfig.capturedPieces.white.push(aiMove.captured);
                        }
                    }
                
                    // Make the move
                    chess.move(aiMove);
                    
                    // Highlight the move
                    gameConfig.highlightSquares = [aiMove.from, aiMove.to];
                    
                    // Update displays
                    updateBoard();
                    updateMoveHistory();
                    
                    // Clear thinking indicator
                    thinkingIndicator.textContent = "";
                    
                    // Add dialogue based on game state
                    let dialogue = '';
                    if (chess.in_check()) {
                        dialogue = `${currentPlayer === 'w' ? 'Stockfish' : 'DeepChess'}: "Check! The ${currentPlayer === 'w' ? 'black' : 'white'} king is under attack."`;
                    } else if (chess.history().length > 10) {
                        // Simplified position evaluation - in a real chess engine this would be much more sophisticated
                        const material = calculateMaterialBalance();
                        if (currentPlayer === 'w' && material > 3) {
                            dialogue = `Stockfish: "I have a material advantage of +${(material/10).toFixed(1)}. Position is clearly winning."`;
                        } else if (currentPlayer === 'w' && material < -3) {
                            dialogue = `Stockfish: "Despite being down material (${(material/10).toFixed(1)}), I have compensation in piece activity."`;
                        } else if (currentPlayer === 'b' && material < -3) {
                            dialogue = `DeepChess: "Material advantage of +${(Math.abs(material)/10).toFixed(1)}. The position is strategically winning."`;
                        } else if (currentPlayer === 'b' && material > 3) {
                            dialogue = `DeepChess: "Although down in material (${(Math.abs(material)/10).toFixed(1)}), my pieces have greater mobility."`;
                        } else {
                            dialogue = `${currentPlayer === 'w' ? 'Stockfish' : 'DeepChess'}: "${aiMove.san} improves my position. Planning the next phase of the game."`;
                        }
                    } else {
                        dialogue = `${currentPlayer === 'w' ? 'Stockfish' : 'DeepChess'}: "${aiMove.san} follows opening principles. Developing pieces and controlling the center."`;
                    }
                    
                    dialogueBox.textContent = dialogue;
                    
                    // Check for game end conditions
                    if (chess.game_over()) {
                        if (chess.in_checkmate()) {
                            const winner = currentPlayer === 'w' ? 'white' : 'black';
                            endGame(winner, 'checkmate');
                        } else if (chess.in_draw()) {
                            endGame(null, 'draw');
                        }
                    } else {
                        // Switch active player timer
                        startTimer(chess.turn());
                        
                        // Schedule next AI move
                        setTimeout(makeAiMove, 100);
                    }
                }, gameConfig.moveDelay);
                
            }, thinkingTime);
        }
        
        // Helper function to calculate material balance (positive favors white, negative favors black)
        function calculateMaterialBalance() {
            const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
            let balance = 0;
            
            // Count all pieces on the board
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = chess.board()[row][col];
                    if (square) {
                        const value = pieceValues[square.type];
                        balance += square.color === 'w' ? value : -value;
                    }
                }
            }
            
            return balance;
        }
        
        // Function to start a new game
        function startNewGame() {
            // Reset game state
            chess.reset();
            gameConfig.gameInProgress = true;
            gameConfig.gamePaused = false;
            gameConfig.timers = { white: 300, black: 300 };
            gameConfig.highlightSquares = [];
            gameConfig.capturedPieces = { white: [], black: [] };
            
            // Update UI
            createBoard();
            updateTimerDisplay();
            whiteThinkingContent.innerHTML = '';
            blackThinkingContent.innerHTML = '';
            whiteThinkingIndicator.textContent = '';
            blackThinkingIndicator.textContent = '';
            dialogueBox.textContent = 'Game started. White to move.';
            moveHistory.textContent = '';
            
            // Update buttons
            startBtn.textContent = 'Restart';
            startBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2v6h6"></path><path d="M3 13a9 9 0 1 0 3-7.7L3 8"></path></svg>Restart';
            pauseBtn.disabled = false;
            pauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>Pause';
            drawBtn.disabled = false;
            resignBtn.disabled = false;
            
            // Adjust entropy for this game to add variety
            gameConfig.entropyFactor = Math.random() * 0.3 + 0.1; // Between 0.1 and 0.4
            
            // Start the game with white
            startTimer('w');
            makeAiMove();
        }
        
        // Function to pause/resume the game
        function togglePause() {
            gameConfig.gamePaused = !gameConfig.gamePaused;
            
            if (gameConfig.gamePaused) {
                stopTimer();
                pauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>Resume';
                dialogueBox.textContent = 'Game paused';
            } else {
                pauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>Pause';
                dialogueBox.textContent = `Game resumed. ${chess.turn() === 'w' ? 'White' : 'Black'} to move.`;
                startTimer(chess.turn());
                makeAiMove();
            }
        }
        
        // Function to offer a draw
        function offerDraw() {
            if (!gameConfig.gameInProgress || gameConfig.gamePaused) return;
            
            // Random chance for opponent to accept draw based on material balance
            const materialBalance = calculateMaterialBalance();
            const currentPlayer = chess.turn();
            
            // If the player offering the draw is in a worse position, higher chance of acceptance
            let acceptChance;
            if (currentPlayer === 'w') {
                // White is offering draw
                acceptChance = materialBalance < 0 ? 0.8 : 0.3;
            } else {
                // Black is offering draw
                acceptChance = materialBalance > 0 ? 0.8 : 0.3;
            }
            
            // Random decide if draw is accepted
            if (Math.random() < acceptChance) {
                dialogueBox.textContent = `${currentPlayer === 'w' ? 'DeepChess' : 'Stockfish'} accepts the draw offer. Game ends in a draw.`;
                endGame(null, 'draw-agreement');
            } else {
                dialogueBox.textContent = `${currentPlayer === 'w' ? 'DeepChess' : 'Stockfish'} declines the draw offer. Game continues.`;
            }
        }
        
        // Function to resign the game
        function resign() {
            if (!gameConfig.gameInProgress || gameConfig.gamePaused) return;
            
            const currentPlayer = chess.turn();
            const winner = currentPlayer === 'w' ? 'black' : 'white';
            
            endGame(winner, 'resignation');
        }
        
        // Function to toggle theme
        function toggleTheme() {
            gameConfig.darkTheme = !gameConfig.darkTheme;
            
            if (gameConfig.darkTheme) {
                document.body.classList.add('dark-theme');
                themeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>Light Theme';
                themeBtn.classList.add('active');
            } else {
                document.body.classList.remove('dark-theme');
                themeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>Dark Theme';
                themeBtn.classList.remove('active');
            }
        }
        
        // Function to toggle infinite mode
        function toggleInfiniteMode() {
            gameConfig.infiniteMode = !gameConfig.infiniteMode;
            
            if (gameConfig.infiniteMode) {
                infiniteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18.178 8c5.076 0 5.076 8 0 8h-6.351"></path><path d="M13.65 16c-5.075 0-5.075-8 0-8h6.351"></path></svg>Infinite: ON';
                infiniteBtn.classList.add('active');
            } else {
                infiniteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18.178 8c5.076 0 5.076 8 0 8h-6.351"></path><path d="M13.65 16c-5.075 0-5.075-8 0-8h6.351"></path></svg>Infinite: OFF';
                infiniteBtn.classList.remove('active');
            }
        }
        
        // Function to end the game
        function endGame(winner, reason) {
            gameConfig.gameInProgress = false;
            stopTimer();
            
            // Update win counter
            if (winner) {
                gameConfig.wins[winner]++;
                whiteWins.textContent = `Wins: ${gameConfig.wins.white}`;
                blackWins.textContent = `Wins: ${gameConfig.wins.black}`;
            }
            
            // Show game end message
            let endMessage = '';
            if (reason === 'checkmate') {
                endMessage = `Checkmate! ${winner === 'white' ? 'Stockfish' : 'DeepChess'} wins the game.`;
            } else if (reason === 'timeout') {
                endMessage = `Time's up! ${winner === 'white' ? 'Stockfish' : 'DeepChess'} wins on time.`;
            } else if (reason === 'draw') {
                endMessage = 'Game drawn. The position is a stalemate or repetition.';
            } else if (reason === 'draw-agreement') {
                endMessage = 'Game drawn by agreement.';
            } else if (reason === 'resignation') {
                endMessage = `${winner === 'white' ? 'Stockfish' : 'DeepChess'} wins by resignation.`;
            }
            
            dialogueBox.textContent = endMessage;
            whiteThinkingIndicator.textContent = '';
            blackThinkingIndicator.textContent = '';
            
            // Update buttons
            pauseBtn.disabled = true;
            drawBtn.disabled = true;
            resignBtn.disabled = true;
            
            // Start a new game automatically if in infinite mode
            if (gameConfig.infiniteMode) {
                setTimeout(() => {
                    startNewGame();
                }, 3000); // Wait 3 seconds before starting a new game
            }
        }
        
        // Function to change game speed
        function cycleGameSpeed() {
            const speeds = ['slow', 'normal', 'fast'];
            const speedLabels = {
                'slow': '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>Slow',
                'normal': '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>Normal',
                'fast': '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>Fast'
            };
            
            const currentIndex = speeds.indexOf(gameConfig.speed);
            const nextIndex = (currentIndex + 1) % speeds.length;
            gameConfig.speed = speeds[nextIndex];
            
            // Update speed config
            const speedPreset = SPEED_PRESETS[gameConfig.speed];
            gameConfig.whiteThinkingTime = speedPreset.white;
            gameConfig.blackThinkingTime = speedPreset.black;
            gameConfig.moveDelay = speedPreset.moveDelay;
            
            // Update button text
            speedBtn.innerHTML = speedLabels[gameConfig.speed];
        }
        
        // Event listeners
        startBtn.addEventListener('click', startNewGame);
        pauseBtn.addEventListener('click', togglePause);
        speedBtn.addEventListener('click', cycleGameSpeed);
        drawBtn.addEventListener('click', offerDraw);
        resignBtn.addEventListener('click', resign);
        themeBtn.addEventListener('click', toggleTheme);
        infiniteBtn.addEventListener('click', toggleInfiniteMode);
        
        // Initialize the board
        createBoard();
    </script>
</body>
</html>